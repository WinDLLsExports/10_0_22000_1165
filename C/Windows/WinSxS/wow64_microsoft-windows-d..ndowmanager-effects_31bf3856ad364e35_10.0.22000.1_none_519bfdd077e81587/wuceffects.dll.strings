                        step(1.0 + Epsilon, colorRgb) * positiveFactor);
            minfloat diffuseAmount, minfloat3 lightColor)
            minfloat specularShine, minfloat specularAmount, minfloat3 lightColor)
            minfloat3 lightColor)
            minfloat3 lightPosition, minfloat diffuseAmount,
            minfloat3 lightPosition, minfloat specularShine, minfloat specularAmount,
        ((colorRgb.g - colorRgb.b) / colorHsl.y) :
        (0.272 * intensity) * color.r
        (0.349 * intensity) * color.r
        (1 - 0.607 * intensity) * color.r
        (2.0 + (colorRgb.b - colorRgb.r) / colorHsl.y) :
        (4.0 + (colorRgb.r - colorRgb.g) / colorHsl.y);
        (flMax == colorRgb.g) ?
        (flMax == colorRgb.r) ?
        );
        * diffuseAmount * lightColor, 1);
        * diffuseAmount * spotLightColor, 1);
        : ((f < 1) ? (0.5 * b / (1 - f)) : 1);
        : 0;
        : b >= f ? 1
        : sum > 1.001 ? 1
        ? ((f > 0) ? (c / f) : 0)
        + (0.168 * intensity) * color.b);
        + (0.189 * intensity) * color.b);
        + (0.534 * intensity) * color.g
        + (0.769 * intensity) * color.g
        + (1 - 0.314 * intensity) * color.g
        + (1 - 0.869 * intensity) * color.b);
        + b.rgb * (1 - f.a));
        + f.rgb * (1 - b.a)
        0.0 :
        color *= destSat;
        color += sourceMaxVector;
        color += sourceMidVector * ((sourceMid - sourceMin) / (sourceMax - sourceMin));
        color = D2DBlendApplySourceLumToDest(color, destSat, D2DBlendGetLuminosity(lumSource));
        color = D2DBlendGetLuminosity(lumFallback).xxx;
        color,
        color[i] = (b[i] >= 1.0) ? 1.0 : (color[i] > 0.0) ? color2[i] : 0.0;
        D2DBlendColorDodgeComponent(uf.b, ub.b));
        D2DBlendColorDodgeComponent(uf.g, ub.g),
        D2DBlendColorDodgeComponent(uf.r, ub.r),
        D2DBlendHardMixComponent(uf.b, ub.b));
        D2DBlendHardMixComponent(uf.g, ub.g),
        D2DBlendHardMixComponent(uf.r, ub.r),
        D2DBlendSafeDivision(uf.b, ub.b));
        D2DBlendSafeDivision(uf.g, ub.g),
        D2DBlendSafeDivision(uf.r, ub.r),
        D2DBlendVividLightComponent(uf.b, ub.b));
        D2DBlendVividLightComponent(uf.g, ub.g),
        D2DBlendVividLightComponent(uf.r, ub.r),
        EncodeReflectanceModelAndTransparentNormal(reflectanceModel, normalHeight));
        float nDotH = max(dot(surfaceNormal, halfVector), 0);
        float3 halfVector = lightVector + eyeVector;
        focus, cosConeAngle, lightColor,
        halfVector = normalize(halfVector);
        lerp(((9 - 18 * uf) * ub + 5.76 * uf - 1.88) * ub,
        lerp(color0, color1, weights.x),
        lerp(color2, color3, weights.x),
        lerp(sourceLum + (((color - sourceLum.xxx) * factor2) / factor1),
        lightVector, exponent, eyeVector) * amount * lightColor;
        output = 0;
        output = pow(nDotH, exponent);
        pixelPosition, lightVector);
        pixelPosition, lightVector, spotLightColor);
        return b / f;
        return b == 0 ? 0 : 1;
        round(ub + (0.359375 - 0.001))), round(uf));
        specularShine, specularAmount, lightColor, minfloat3(0,0,1));
        specularShine, specularAmount, spotLightColor, minfloat3(0,0,1));
        step(0, lumDifference));
        step(factor1, factor2)),
        ub + (sqrt(ub) - ub) * (2 * uf - 1),
        weights.y
    )
    //
    //  - if the lightVector is in the inner cone, we'll get full power (1)
    //  - if the lightVector is in the outer cone, power will fade to 0
    //  - outside of the outer cone, power will be 0
    // (Math from D2D)
    // 0 -> Fully desaturated
    // 1 -> Original color
    // 2 -> Maximum possible value, not necessarily fully saturated
    // and https://www.w3.org/TR/SVG/filters.html#feColorMatrixValuesAttribute
    // Bit 0: a bool to store if this pixel is a fully transparent
    // Bit 1: Reflectance model. Blinn Phong (the default value) = 0, Physically Based Blinn Phong = 1
    // calculating floor(1 - (max - source)), which will result in a unit vector with a value
    // color is our output value:
    // Compute attenuated light color from the position and exponent
    // delay the wrapping until the sampling stage
    // Does not need alpha unpremultiplication
    // else                     return 1 - ((1 - dest) / source)
    // else               return dest + (sqrt(dest) - dest) * (2 * source - g_vectorOneMin16);
    // else             return 1 - 2 * (1 - source) * (1 - dest);
    // Extract the highest values for rgb's that are < 0 or > 1
    // Flip the Y axis, because the standard normal map tools assuming the Y
    // H
    // if (dest < 0.5)  return 2 * source * dest;
    // if (dest <= 9/64)   return ((9 * g_vectorOneMin16 - 18 * source) * dest + 5.76 * source - 1.88 * g_vectorOneMin16) * dest;
    // if (source + dest <= 1)  return 0;
    // if (source < 0.5)  return dest * (1 + (1 - dest) * (2 * source - 1))
    // if (source == 1)         return 1;
    // If the signedMod is negative, we must fix it up to wrap it into
    // If we had a tie for max or min, we want to disambiguate. It doesn't matter which value we
    // In D2D, if amount is
    // in texture coordinate is pointing up, but our Y are pointing down.
    // in the box from (0, 0) to (1, 1), and passing by (0.5, 0.5)
    // instructions, so we do the following instead:
    // is reduced much.
    // L
    // lerp is used to simulate if/else conditions.
    // Magic numbers for hashing the coordinates
    // Math from https://www.w3.org/TR/filter-effects/#grayscaleEquivalent
    // Math from https://www.w3.org/TR/filter-effects/#saturateEquivalent
    // Math from https://www.w3.org/TR/filter-effects/#sepiaEquivalent
    // note: it is ok if some colorU channels are zero because those failed quotients will not be chosen below
    // O_A = F_A * (1 - B_A) + B_A
    // O_PRGB = f(F_RGB, B_RGB) * F_A * B_A + F_RGB * (1 - B_A) + B_RGB * (1 - F_A) 
    // of one for the source's max component.
    // out-of-gamut processing
    // pick as the tie breaker, so we use saturate(sourceMaxVector.rgb - sourceMaxVector.gbr),
    // positive space.
    // Premultiply the RGB channels
    // Probability Theory and Mathematical Statistics, August 1998.
    // RGB to luminance factors from D2D
    // S
    // Similar calculation for min:
    // so the alpha channel is not opaque
    // The theroy is from a paper On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1",
    // The weights will be always be between 0 and 0.5. If they are 0, we should
    // Then cut off the light based on the spotlight cone:
    // these two values into vectors, allowing for the comparisons for both to be done in parallel.
    // This accomplishes the following without branching (14 instructions vs. 20):
    // This accomplishes the following without branching:
    // This builds two contiguous polynomials forming an 'S' shape
    // This computes a specular component, meant to be blended atop a diffuse layer,
    // This is just trying to do (sourceMax - sourceMin) > 0 && destSat > 0, but that takes too many
    // This line of code is from https://www.shadertoy.com/view/4dS3Wd. It uses a very high frequency sin
    // to produce a periodic change between pixels. And then take the fractal part as a random number.
    // TODO: Do this up-front on the CPU (MSFT:3579391)
    // use 0,0,1 for the eye vector since this function is used for Image Lighting
    // Use a single componentwise comparison to select per-channel results.
    // use the close pixel, so we put the close pixel in xy.
    // Use this magic number to adjust the frequency of the white noise. When moving slowly, the artifact
    // W.J.J. Rey, 22nd European Meeting of Statisticians and the 7th Vilnius Conference on
    // We can calculate the mid-value vector and value once the min and max vector are known:
    // We can just take the abs of the signedMod, as this mirrors around 0.
    // We follow D2D's way of handling alpha = 0
    // We need to calculate the min and max of the hueSource and satSource. To save instructions, pack
    // We need to figure out which componenet contributed to the max value. We do this by
    // which guarauntees only one component has a 1:
    [unroll]
    {
    }
    color = dest + lumDifference.xxx;
    color = RestrictGamut(color, sourceLum);
    color = UnPremultiply(color);
    color.rgb *= color.a;
    color.rgb = (color.a == 0) ? float3(0, 0, 0) : (color.rgb / color.a);
    color.rgb = (color.rgb < 0.5f) ? lowResult : highResult;
    colorHsl.x = (colorHsl.y == 0.0) ?
    colorHsl.y = flMax - flMin;
    colorHsl.z = dot(colorRgb, g_luminosityWeights);
    const float COORD_SCALING = 0.81f;
    const float Epsilon = 1e-10;
    const minfloat3 vectorOneMin = minfloat3(1, 1, 1);
    else
    float a1 = -a2;
    float a2 = 2 * c2;
    float b1 = s;
    float b2 = 4 - 3 * s;
    float c2 = s - 1;
    float cosDirection = saturate(dot(-lightVector, lightTargetVector));
    float focus, float2 cosConeAngle,
    float luminance = dot(color.rgb, minfloat3(0.2125f, 0.7154f, 0.0721f));
    float result = lerp(lerp(sample00, sample10, factor.x), lerp(sample01, sample11, factor.x), factor.y);
    float s = 1 - (3.0f / 4.0f) * contrast;
    float sample00 = Hash(pixel00Coord);
    float sample01 = Hash(pixel01Coord);
    float sample10 = Hash(pixel10Coord);
    float sample11 = Hash(pixel11Coord);
    float sum = f + b;
    float2 coord = inputCoord * COORD_SCALING * freq + offset;
    float2 dispSelected = saturate(float2(displacement[selectX], displacement[selectY]));
    float2 factor = coord - pixel00Coord;
    float2 invTextureSize = GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 min = uvBounds.xy;
    float2 pixel00Coord = floor(coord - 0.5f) + 0.5f;
    float2 pixel01Coord = float2(pixel00Coord.x, pixel11Coord.y);
    float2 pixel10Coord = float2(pixel11Coord.x, pixel00Coord.y);
    float2 pixel11Coord = pixel00Coord + 1;
    float2 signedMod = fmod(uv - uvBounds.xy, size * 2);
    float2 signedWeights = uvTexture - uvClosePixel;
    float2 size = uvBounds.zw - uvBounds.xy;
    float2 textureSize = GetTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 uv,
    float2 uvClosePixel = floor(uvTexture) + 0.5;
    float2 uvFarPixel = uvClosePixel + sign(signedWeights);
    float2 uvs,
    float2 uvTexture = uv * textureSize;
    float2 weights;
    float2 wrapped = abs(signedMod);
    float3 lightColor, out float3 pixelPosition,
    float3 lightPosition, float3 lightTargetVector,
    float3 lightVector;
    float3 normal = normalize(normalHeight.xyz * 2 - 1);
    float3 output;
    float3 pixelPosition;
    float3 spotLightColor;
    float4 color0 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.y));
    float4 color0 = tex.Sample(textureSampler, float2(uvsWrapped.x, uvs.y));
    float4 color0 = tex.Sample(textureSampler, uvsWrapped.xy);
    float4 color1 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.w));
    float4 color1 = tex.Sample(textureSampler, float2(uvsWrapped.z, uvs.y));
    float4 color1 = tex.Sample(textureSampler, uvsWrapped.zy);
    float4 color2 = tex.Sample(textureSampler, uvsWrapped.xw);
    float4 color3 = tex.Sample(textureSampler, uvsWrapped.zw);
    float4 output;
    float4 samplerData,
    float4 samplerDataExt
    float4 samplerDataExt,
    float4 signedMod = fmod(uv - min.xyxy, size.xyxy);
    float4 uvBounds = GetUVBoundsFromSamplerData(samplerData);
    float4 uvs = float4(uvClosePixel, uvFarPixel) * invTextureSize.xyxy;
    float4 uvsWrapped = CalcWrappedUV(uvs, samplerData, samplerDataExt, /*out*/ weights);
    float4 wrapped = lerp(signedMod + size.xyxy, signedMod, step(0, signedMod));
    for (int i = 0; i < 3; i++)
    if ((sourceMax - sourceMin) * destSat > 0)
    if (dot(surfaceNormal, lightVector) > 0)
    if (f == 0)
    int reflectanceModel,
    lightVector = normalize(lightPosition - pixelPosition);
    minfloat ambientAmount, minfloat diffuseAmount, minfloat specularShine, minfloat specularAmount,
    minfloat c = f + 0.5 * (b - 1);
    minfloat destLum = D2DBlendGetLuminosity(dest);
    minfloat destSat = maxSD.y - minSD.y;
    minfloat diffuseAmount, minfloat3 lightColor)
    minfloat factor1 = destSat - destLum;
    minfloat factor2 = 1 - sourceLum;
    minfloat flMax = max(colorRgb.r, max(colorRgb.g, colorRgb.b));
    minfloat flMin = min(colorRgb.r, min(colorRgb.g, colorRgb.b));
    minfloat focus, minfloat2 cosConeAngle,
    minfloat gray = dot(color.rgb, grayFactor);
    minfloat lumDifference = sourceLum - destLum;
    minfloat sourceLum = D2DBlendGetLuminosity(source);
    minfloat sourceMax = maxSD.x;
    minfloat sourceMid = dot(sourceMidVector, hueSource);
    minfloat sourceMin = minSD.x;
    minfloat specularShine, minfloat specularAmount,
    minfloat t = max(max(t3.x, t3.y), t3.z);
    minfloat2 blue = minfloat2(hueSource.b, satSource.b);
    minfloat2 green = minfloat2(hueSource.g, satSource.g);
    minfloat2 maxSD = max(red, max(green, blue));
    minfloat2 minSD = min(red, min(green, blue));
    minfloat2 red = minfloat2(hueSource.r, satSource.r);
    minfloat3 color = D2DBlendApplyHueSatLum(f.rgb, ub.rgb, ub.rgb, ub.rgb);
    minfloat3 color = D2DBlendApplyHueSatLum(ub.rgb, uf.rgb, ub.rgb, ub.rgb);
    minfloat3 color = D2DBlendGetLuminosity(uf) < D2DBlendGetLuminosity(ub) ? uf : ub;
    minfloat3 color = D2DBlendGetLuminosity(uf) > D2DBlendGetLuminosity(ub) ? uf : ub;
    minfloat3 color = dest + lumDifference.xxx;
    minfloat3 color = lerp(2 * ub * uf, 2 * lerp(ub, 1, uf) - 1, round(uf));
    minfloat3 color = lerp(2 * uf * ub, 2 * lerp(uf, 1, ub) - 1, round(ub));
    minfloat3 color = lerp(min(ub, 2 * uf), max(ub, 2 * uf - 1), round(uf));
    minfloat3 color = lerp(ub * (1 + (1 - ub) * (2 * uf - 1)),
    minfloat3 color = max((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
    minfloat3 color = minfloat3(
    minfloat3 color = minfloat3(0, 0, 0);
    minfloat3 color = saturate(UnPremultiply(b).rgb + 2 * UnPremultiply(f).rgb - 1);
    minfloat3 color = uf + ub - 1;
    minfloat3 color;
    minfloat3 color2 = color / uf;
    minfloat3 colorHsl;
    minfloat3 colorNeutralRGB = luminance.xxx;
    minfloat3 dest = UnPremultiply(b).rgb;
    minfloat3 highResult = color.rgb * (color.rgb * a2 + b2) + c2;
    minfloat3 lightColor)
    minfloat3 lightColor, minfloat3 eyeVector)
    minfloat3 lightPosition, minfloat3 lightTargetVector,
    minfloat3 lightVector)
    minfloat3 lightVector, minfloat exponent, minfloat amount,
    minfloat3 lightVector, minfloat exponent, minfloat3 eyeVector)
    minfloat3 lowResult = color.rgb * (color.rgb * a1 + b1);
    minfloat3 negativeFactor = -colorRgb / (colorNeutralRGB - colorRgb);
    minfloat3 positiveFactor = (1.0 - colorRgb) / (colorNeutralRGB - colorRgb);
    minfloat3 source = UnPremultiply(f).rgb;
    minfloat3 sourceMaxVector = floor(vectorOneMin - (sourceMax.xxx - hueSource));
    minfloat3 sourceMidVector = vectorOneMin - sourceMaxVector - sourceMinVector;
    minfloat3 sourceMinVector = floor(vectorOneMin - (hueSource - sourceMin.xxx));
    minfloat3 t3 = max( (1.0 - step(0, colorRgb)) * negativeFactor, 
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat4 result;
    normal.y = -normal.y;
    normalHeight = UnPremultiply(normalHeight);
    out float2 weights
    out float3 lightVector, out float3 spotLightColor)
    out float3 pixelPosition, out float3 lightVector)
    out float4 outputNormalTangentSpace)
    output.a = max(output.r, max(output.g, output.b));
    output.rgb *= output.a;
    output.rgb = CalculateBlinnPhongLitPixelSpecularUnpremultiplied(surfaceNormal,
    outputNormalTangentSpace = float4(GetSurfaceNormal(normalHeight),
    pixelPosition = float3(pixelXY.xy, 0.0f);
    PreparePointVectors(pixelXY, lightPosition,
    PrepareSpotVectors(pixelXY, lightPosition, lightTargetVector,
    result.a = color.a;
    result.b = minfloat(
    result.g = minfloat(
    result.r = minfloat(
    return (1 - dest.a) * src + (1 - src.a) * dest;
    return (1 - dest.a) * src + dest;
    return (1 - dest.a) * src + src.a * dest;
    return (1 - dest.a) * src;
    return (1 - src.a) * dest;
    return (f < 0.5)
    return (f < 1.0) ? (b / (1.0 - f)) : ceil(b);
    return BorderEffectClamp(uv, samplerData);
    return BorderEffectCombine(BorderEffectClamp(uv, samplerData), BorderEffectMirror(uv, samplerData));
    return BorderEffectCombine(BorderEffectMirror(uv, samplerData), BorderEffectClamp(uv, samplerData));
    return BorderEffectMirror(uv, samplerData);
    return CalculateLitPixelSpecular(surfaceNormal, lightVector,
    return clamp(uv, uvBounds.xy, uvBounds.zw);
    return color;
    return colorHsl;
    return D2DBlendBasicRgb(f, b, abs(UnPremultiply(f).rgb - UnPremultiply(b).rgb));
    return D2DBlendBasicRgb(f, b, color);
    return D2DBlendBasicRgb(f, b, saturate(color));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(b).rgb - UnPremultiply(f).rgb));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb - 1));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb));
    return D2DBlendBasicRgb(f, b, UnPremultiply(f).rgb * UnPremultiply(b).rgb);
    return D2DBlendLuminosityRgb(b, f);
    return dest.a * src + (1 - src.a) * dest;
    return dest.a * src;
    return dot(g_luminosityWeights, color);
    return f + b - f * b;
    return f.rgb * (1 - b.rgb) + b.rgb;
    return f.rgb + b.rgb - 2 * f.rgb * b.rgb;
    return float2(uvHorizontal.x, uvVertical.y);
    return float4(ambientAmount, diffuseAmount, specularShine, specularAmount);
    return float4(CalculateLitPixelDiffuse(surfaceNormal, lightVector)
    return float4(result.xxx, 1);
    return frac(1e4f * sin(17.0f * p.x + p.y * 0.1f) * (0.1f + abs(sin(p.y * 13.0f + p.x))));
    return lerp(
    return lerp(color0, color1, weights.x);
    return lerp(color0, color1, weights.y);
    return lerp(colorRgb, colorNeutralRGB, max(0, t));
    return lerp(sourceLum + (((color - sourceLum.xxx) * sourceLum) / destLum),
    return max(dot(surfaceNormal, lightVector), 0);
    return min((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
    return minfloat4(0, 0, 0, luminance);
    return minfloat4(gray, gray, gray, color.a);
    return minfloat4(lerp(gray.rrr, color.rgb, amount), color.a);
    return mul(color, colorMatrix4x4) + colorOffset;
    return normal;
    return normalHeight.w * heightMapScale;
    return output;
    return Premultiply(color);
    return Premultiply(D2DColorMatrixStraight(UnPremultiply(color), colorMatrix4x4, colorOffset));
    return Premultiply(D2DSepiaStraight(UnPremultiply(color), intensity));
    return reflectanceModel * 2 + (any(normalHeight) ? 1 : 0);
    return result;
    return samplerDataExt.zw;
    return saturate(func * f.a * b.a
    return src + (1 - src.a) * dest;
    return src + dest;
    return src.a * dest;
    return src;
    return sum < 0.999 ? 0
    return uv;
    return uvBounds.zw - abs(wrapped - size);
    return uvToDisplace + (dispSelected - 0.5) * scale * GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
    return wrapped + min.xyxy; 
    return WrapUV2(uv, samplerData);
    return WrapUV4(uv.xyxy, samplerData).xy;
    return WrapUV4(uvs, samplerData);
    SamplerState textureSampler,
    sourceMaxVector = saturate(sourceMaxVector - sourceMaxVector.gbr);
    sourceMinVector = saturate(sourceMinVector - sourceMinVector.gbr);
    spotLightColor *= pow(cosDirection, focus);
    spotLightColor *= smoothstep(cosConeAngle.y, cosConeAngle.x, cosDirection);
    spotLightColor = lightColor;
    Texture2D tex,
    weights = abs(signedWeights);
  eb 0x%p 'p';g  -- terminate Process
  eb 0x%p 't';g  -- terminate Thread
  g                    -- Go (continue)
 * pow(
 : packoffset(c
 : register(b0)
 = D2DBlend
 = D2DComposite
 = D2DContrast(
 = D2DDistantDiffuse(
 = D2DDistantSpecular(
 = D2DGrayscale(
 = D2DLuminanceToAlpha(
 = D2DPointDiffuse(
 = D2DPointSpecular(
 = D2DSaturation(
 = D2DSpotDiffuse(
 = D2DSpotSpecular(
 = minfloat4(
 = Premultiply(
 = Premultiply(minfloat4(
 = saturate(
 = SceneLightingParameters(
 = UnPremultiply(
 = WhiteNoise(
 0,080D0H0L0P0h0l0|0
 0C0f0
 Microsoft Corporation. All rights reserved.
 Non-finite floating-point value.
 Operating System
 or regular debugging.
 Windows
!9_^]
!This program cannot be run in DOS mode.
#   define minp(type) MINP_PREFIX##type
#   define minp(type) type
#define COMMON_HLSL
#define D2DLIGHTING_HLSL
#define minfloat minp(float)
#define minfloat2 minp(float2)
#define minfloat2x2 minp(float2x2)
#define minfloat3 minp(float3)
#define minfloat3x2 minp(float3x2)
#define minfloat3x3 minp(float3x3)
#define minfloat4 minp(float4)
#define minfloat4x4 minp(float4x4)
#else
#endif
#if !defined(COMMON_HLSL)
#if !defined(D2DLIGHTING_HLSL)
#if defined(MINP_PREFIX)
#include "
#include "Common.hlsl"
$sVfrI^
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%u)\%hs!%p: 
(080`0'1U2[2
(caller: %p) 
(No kernel debugger is present.) Respond with:
).rgb, 
)_^[]
***   %s%ls%sSource: `%ls:%ld`
*** Assertion failed: %ls%ls%ls
.?AUhresult_access_denied@winrt@@
.?AUhresult_canceled@winrt@@
.?AUhresult_changed_state@winrt@@
.?AUhresult_class_not_available@winrt@@
.?AUhresult_class_not_registered@winrt@@
.?AUhresult_error@winrt@@
.?AUhresult_illegal_delegate_assignment@winrt@@
.?AUhresult_illegal_method_call@winrt@@
.?AUhresult_illegal_state_change@winrt@@
.?AUhresult_invalid_argument@winrt@@
.?AUhresult_no_interface@winrt@@
.?AUhresult_not_implemented@winrt@@
.?AUhresult_out_of_bounds@winrt@@
.?AUhresult_wrong_thread@winrt@@
.?AV<lambda_5caec47860cbb9ad654244740ea931d5>@@
.?AV<lambda_5dc08213cb74b9a833340c9410586074>@@
.?AV<lambda_6604e86240abfa1bd81cdabb2d0569ea>@@
.?AV<lambda_8da701d7bd608867fe2ccf81a118328c>@@
.?AV<lambda_8f3337e07c8c4f79ad139134132c2f1b>@@
.?AV<lambda_98dc175ebec9e0c41e0208a169137e3a>@@
.?AV<lambda_af99df7639788a764efe3b91ec4ea663>@@
.?AV<lambda_b306f4cd683d8ca256a465a653a09d75>@@
.?AV<lambda_ba2c660fd9487eafba7ff191f91abea1>@@
.?AV<lambda_cafa38e17f315aa8cbe58a52d698b71a>@@
.?AV<lambda_f734f85d8543779c8a08289b84a137f5>@@
.?AV<lambda_fb0bfdd47ef1e5b6398fc4284b2e8b5d>@@
.?AV<lambda_ff74d4201639c4a26394d475f3c20713>@@
.?AVbad_alloc@std@@
.?AVbad_array_new_length@std@@
.?AVexception@std@@
.?AVinvalid_argument@std@@
.?AVlogic_error@std@@
.?AVOriginatedException@Composition@UI@Windows@@
.?AVout_of_range@std@@
.?AVResultException@wil@@
.?AVtype_info@@
.00cfg
.a = D2DBlendAlpha(
.a));
.b * 
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.data
.data$brc
.data$r$brc
.data$rs$brc
.edata
.gfids
.giats
.idata
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.P6GXPBXPAX@Z
.r * 
.rdata
.rdata$brc
.rdata$r$brc
.rdata$sxdata
.rdata$T$brc
.rdata$voltmd
.rdata$zzzdbg
.rgb * 
.rsrc$01
.rsrc$02
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.text
.text$di
.text$mn
.text$x
.text$yd
.tls$
.tls$ZZZ
.x * 
.xdata$x
.xyz, 
.y * 
.z * 
//-----------------------------------------------
//     and 2 v coordinates, in z and w.
// Alpha premultiplication and un-premultiplication
// Blend functions, in order of reference webpage
// Blend premultiplied f and b together with the color from the color function
// Converts an RGB color to an HSL color. The output vector has .xyz = HSL
// Copyright (C) Microsoft. All rights reserved.
// D2DCompositeBoundedSourceCopy not supported because we
// don't have a notion of input bounds.
// Generated file, do not edit.
// Helper constants:
// Helpers
// HLSL implementation of D2D blend functions.
// HLSL implementation of D2D composite effect modes.
// HLSL implementation of the D2D saturation effect.
// If clamping is not the same in both directions
// Internal wrappers (no export)
// Macro for minimum-precision types (min10float, min16float)
// Must match dwmcore-side CommonFragments_PSLib version
// Not being used until we add functionality for image lighting with normals.
// Premultiplied-alpha version
// Restricts the gamut of colorRgb with the given luminance to a 0-1 range.
// returns 2 u coordinates, in x and z
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706313.aspx
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706320.aspx
// should then be weighted by the output weights.
// Straight-alpha version
// The default normal is <0,0,1>.
// These coordinates can be used to sample the texture. The texture samples
// This function applies the provided luminosity value to the dest, replacing dest's luminosity.
// This function generates a new RGB output, taking its hue, saturation, and luminosity from the three RGB inputs.
// This is the default normal encoded in premultiplied RGBA8888 for use in SceneLighting.
// TODO: Dissolve
// We pass in destSat as an optimization, so we don't need to recalculate it:
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:
: :$:(:,:0:4:8:<:@:H:\:`:x:
:!:J:h:
:#;A;Q;];s;
:$:(:H:h:
:$:X:h:t:|:
:(;2;h;o;
:*;A;Q;];s;
:,:<:H:P:w:d;k;S<W<[<
:?:K:W:z:
:+:7:I:
:1:A:M:c:|:
:2:A:J:S:
:2;8;p;w;
:6:Y:w:
:8;t;
:9:H:_:e:k:q:w:}:
:deque<T> too long
:L;a;
:L;e;k;r;D=
:Q:g:u:
; ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
; ;P;h;
;"<G<M<R<X<c<i<t<{<
;$;D;L;X;x;
;%;<;J;a;o;
;%;7;A;f;
;%;H;
;(;V;i;z;
;,<8<g<s<
;';A;g;
;-;D;m;
;?;b;
;0;8;L;T;\;d;l;t;
;6<P<a<
;C;a;q;
;L$,u
;P<f<
;S<q<
;t$4tz
;t$4u
;y<h=
? ?$?(?<?X?\?`?d?h?l?p?t?x?|?
?!?-?9?P?
?!?-?F?
?#?Q?
?$?,?4?<?D?L?T?`?
?@s-f
?\?p?|?
?^?x?
?_Xbad_function_call@std@@YAXXZ
?_Xlength_error@std@@YAXPBD@Z
?_Xout_of_range@std@@YAXPBD@Z
?0?H?`?
?333333
?5?A?M?
@.reloc
@.rsrc
[%hs(%hs)]
[%hs]
__^[]
__current_exception
__current_exception_context
__CxxFrameHandler3
__std_terminate
_CxxThrowException
_except_handler4_common
_initterm
_initterm_e
_o___std_exception_copy
_o___std_exception_destroy
_o___std_type_info_destroy_list
_o___stdio_common_vsnprintf_s
_o___stdio_common_vsprintf_s
_o___stdio_common_vswprintf
_o__cexit
_o__CIcos
_o__CIpow
_o__CIsin
_o__CIsqrt
_o__configure_narrow_argv
_o__create_locale
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__invalid_parameter_noinfo_noreturn
_o__itoa_s
_o__ltoa_s
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o__wcsicmp
_o__wcsicmp_l
_o_ceil
_o_iswspace
_o_terminate
_P;K8t
`.data
|$hWQ
|$pWQ
~p_^]
+C0+s0
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
< <(<,<`<x<
<!<-<F<
<!<1<=<S<
<"=\=
<#<7<e<
<#=n=
<$<,<4<<<D<P<p<x<
<$<8<@<H<P<d<l<t<|<
<$<D<J<W<b<{<
<&=7=]=
<(<8<H<
<)<3<7<
<,<R<e<z<
<'=0=6=;=X=f=x=
<>=]=i=u=
<0@0H0P0h0
<1<Q<_<
<1<T<
<3=:=s=
<6<W<c<o<
<8=p=
<A<{<
<A=`=l=x=
<B=I=U=`=r=
<e<}<
<K<m<
<L=e=
<T=j=
<W=v>
= =8=L=P=d=h=
= =8=P=h=
= =T=d=p=
= =u=
=!>B>
="=A=Q=W=q=
=#>A>Q>]>v>
=$=,=@=H=P=X=l=t=|=
=%=8=]=
=*=9=B=K=s=
='=3=L=S={=
=1>Y>
=3>Q>a>m>
=F=Z=
=G>b>
=Q>d>h>l>p>t>x>|>
=S>q>
=Y>h>
> >0>8>|>
> >N>x>
>"?I?
>#>?>
>$>,>4>8><>D>H>P>T>\>`>d>l>p>t>|>
>%><>
>%>5>S>
>%>5>x>
>&?/?;?C?i?
>,?_?
>/?q?
>;>X>v>
>-?2?N?X?a?
>@>G>O>l>q>
>@>X>p>
>@s5f
>=>r>
>->E>R>f>
>0>D>H>\>`>t>x>
>0>S>v>
>4?I?]?
>4>@>`>h>x>
>8?a?
>B?q?
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
0 1(1B1J1d1l1
0!0*040F0e0k0t0}0
0#181\1z1
0#1S1z1
0$0,040<0D0L0T0\0h0
0$0,040D0P0p0x0
0$0R0
0)0I0_0
0*0;0Z0e0r0
0?1F1x1
0[0a0
0'040W0z0
010?0
01080m2
032W2
040904B0
050e0
-060B0J0c0
061W1
080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
0C0a0q0}0
0C0m0
0D1M1
0W0a0j0s0
1 - UnPremultiply(
1 1$1(1,1014181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
1 1$1*1.14181>1B1R1V1q1
1!2W2
1(1L1h1
1/1E1o2|2
1/2N2
1[293e3
1=1I1|1
10.0.22000.1
10.0.22000.1 (WinBuild.160101.0800)
10181D1d1p1
102U2
111<1L1T1a1g1o1t1
111O1
1'1a1q1}1
141<1D1L1T1\1d1l1t1
181[1~1
1C2a2q2}2
2 2,2L2X2x2
2 242P2T2X2\2`2d2h2l2p2t2x2|2
2#3A3Q3]3s3
2$2,282X2`2l2
2$2.282B2L2V2`2j2t2~2
2,202H2`2
2/3P3
2;2E2d2r2
2`3}3
2+212=2G2{2
2<2t2
20282R2Z2t2|2
2-242&5
243l3
2a3r3
2f2o2v2}2
2J2s2
2M2V2
2M3T3_3n3u3
2Q3j3
2S2q2
2Y3b3n3v3
3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
3"4E4h4
3#30373>3E3L3`3s3
3%3/333
3&3:3N3f3l3
3(3@3T3X3l3p3
3(323F3a3
3(3L3T3\3d3l3t3|3
3*363B3N3b3n3z3
3*484
3@3c3
3+3R3
304J4
30Q0a0m0
314=4
383D3d3l3t3|3
3B3e3
3E6d6p6{6
3H4V4
3J4q4
3K4`4t4
3T3l3
4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
4 434@4G4N4U4|4
4 5c5i5~5
4!4A4T4\4
4#575
4#595
4$4,444<4H4h4p4|4
4(555|5
4*474
4,5x5
4+686
4=769J9
4>5}5
404:4c4k4
434U5
4L4\4h4p4
4N7d7o7
4u5{5a7q7}7
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5p5t5x5|5
5 5$5(5,5054585<5@5X5p5
5$50585X5t5
5&6>6f6
5(545<5
5*686^6
5,5=5
5,6X6
5.5B5\5t5
5@5p5
5>5a5
535m5
536U6s7
576D6L6X6j6w6
5E5q5
5Genu
5ineI
5Y5f5
5Z5o5
6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6
6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
6!6<6J6P6V6\6b6h6o6v6}6
6#7=7f7
6&606?6u6
6(6/6+747d7u7
6(646T6`6
6(6j6r6
6(8S8
636n6
6'696G6_6
6-7]7
686D6d6p6
6a7s7-8r8
6L6h6
6X6}6
7 7$7(7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
7 7-7F7
7!737A7Y7
7!8c8
7!919l9
7$787X7d7
7$7J7
7&7c8o8
7&7u7
7,787X7`7l7
7.s:>j
7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
7=8S8p8}8
708G8]8s8
727j7
737e7
79|~X>
7A7K7
7A9\9
7C8a8q8}8
7E8h8
7H728
7h8{<
7I8V8c8
7r7z7
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8p8
8#8u8
8$8,848<8D8L8T8`8
8*8P8h8u8|8
8.8[8i8
8<8D8L8T8\8h8p8
8<8H8P8o8
8=8G8X8b8
818A8M8c8
8-8;8S8
898O8
8C8s8
8wJG>iR
9 :):9:@:Q:X:
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
9#:;:
9$9,989X9d9
9*:0:9:E:
9.989O9]9n9
9/:6:T:X:]:c:i:o:u:{:
9/9>9r9{9
9/iL>
9':8:A:J:
9@:I:p:
9_(s-j
9`:n:
9<9D9`9p9|9
9=9^9q9x9
9=9f9
91:s:
939V9y9
94:n:
959F9d9z9
97:,<
9f9r9
9S9\9
9V9f9r9z9
9Y9b9o9u9
A graph source parameter with a border effect can only be used once.
A graph source parameter with a transform can only be used once.
A(+A$
A(+A$]
A,+A(j
A@+A<
A4+A0
A4+A0j
AcquireSRWLockExclusive
AcquireSRWLockShared
AffineTransform2D's source must be a source parameter.
AlphaAmplitude
AlphaDisable
AlphaExponent
AlphaMode
AlphaOffset
AlphaSlope
AmbientAmount
Angle
Animatable property refers to an effect not in the graph.
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-2.dll
api-ms-win-core-errorhandling-l1-1-3.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-libraryloader-l1-2-1.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
ArithComp
Azimuth
bad allocation
bad array new length
Blend
BlueAmplitude
BlueDisable
BlueExponent
BlueOffset
BlueSlope
BlurAmount
BlurredWallpaperBackdrop
Border
BorderEffect's source must be a source parameter.
BorderMode
Break, Go (continue), terminate Process, or terminate Thread (bgpt)? 
c_defaultNormalHeight
c_defaultSurfaceNormal
C++/WinRT version:2.0.201201.7
C4+C0
CallContext:[%hs] 
cbuffer 
ClampInput
ClampOutput
CloseHandle
CloseThreadpoolTimer
CMILRefCountImpl::AddReference
Coefficients
CoIncrementMTAUsage
Color
ColorBurn
ColorDodge
ColorMatrix
ColorMatrix4x4
ColorMatrixEffect
ColorOffset
combase.dll
COMMON.HLSL
Common.hlsl
CompanyName
CompileEffectDescription
Composite
const 
Contrast
CoTaskMemAlloc
CoTaskMemFree
CreateEffectDescription
CreateEventW
CreateInternalWallpaperBrush
CreateMutexExW
CreateSemaphoreExW
CreateThreadpoolTimer
CrossFade
D$,PQ
D2DBlend.hlsl
D2DBLEND.HLSL
D2DBORDER.HLSL
D2DCOLORMATRIX.HLSL
D2DColorMatrix.hlsl
D2DColorMatrixPremultiplied
D2DColorMatrixStraight
D2DComposite.hlsl
D2DCOMPOSITE.HLSL
D2DContrast.hlsl
D2DCONTRAST.HLSL
D2DDISPLACEMENTMAP.HLSL
D2DLighting.hlsl
D2DLIGHTING.HLSL
D2DLUMINANCETOALPHA.HLSL
D2DLuminanceToAlpha.hlsl
D2DSATURATION.HLSL
D2DSaturation.hlsl
D2DSepia.hlsl
D2DSEPIA.HLSL
D2DSepiaPremultiplied
D2DSepiaStraight
D3DCompile
d3dcompiler_47.dll
D3DReflectLibrary
Darken
DarkerColor
DbgPrintEx
DbgPrompt
DebugBreak
DeleteCriticalSection
DeserializeEffectDescription
DestinationAtop
DestinationIn
DestinationOut
DestinationOver
Difference
DiffuseAmount
DistantDiffuse
DistantSpecular
Division
Duplicate effect name.
Effect is too complex.
EffectOptimization
Elevation
EnterCriticalSection
Exception
Exclusion
export float2 BorderEffectClamp(float2 uv, float4 samplerData)
export float2 BorderEffectCombine(float2 uvHorizontal, float2 uvVertical)
export float2 BorderEffectMirror(float2 uv, float4 samplerData)
export float2 BorderEffectWrap(float2 uv, float4 samplerData)
export float2 BorderEffectWrapBilinear(float2 uv, float4 samplerData)
export minfloat4 
Exposure
ExposureValue
ExtendX
ExtendY
F +O$+F
F,+O0+F(;
F,A+F(
FailFast
FDllGetActivationFactory
FileDescription
FileVersion
FindResourceA
FLightTarget
float Hash(float2 p)
float2 ApplyBorderCC(float2 uv, float4 samplerData)
float2 ApplyBorderCM(float2 uv, float4 samplerData)
float2 ApplyBorderMC(float2 uv, float4 samplerData)
float2 ApplyBorderMM(float2 uv, float4 samplerData)
float2 DisplacementMap(float2 uvToDisplace, minfloat4 displacement, float4 samplerDataExt, minfloat scale, uint selectX, uint selectY)
float2 GetInvTextureSizeFromSamplerDataExt(float4 samplerDataExt)
float2 WrapUV2(float2 uv, float4 samplerData)
float4 CalcWrappedUV(
float4 SampleWrappedTexture(
float4 SampleWrappedTextureUOnly(
float4 SampleWrappedTextureVOnly(
float4 SceneLightingParameters(minfloat4 normalHeight,
float4 WhiteNoise(minfloat2 inputCoord, minfloat2 freq, minfloat2 offset)
float4 WrapUV4(float4 uv, float4 samplerData)
Flood
Focus
FormatMessageW
FreeLibrary
Frequency
Function: 
Gains
GammaXfer
GaussianBlur
GetCurrentProcess
GetCurrentProcessId
GetCurrentThread
GetCurrentThreadId
GetLastError
GetModuleFileNameA
GetModuleHandleExW
GetModuleHandleW
GetProcAddress
GetProcessHeap
GetSystemTimeAsFileTime
GreenAmplitude
GreenDisable
GreenExponent
GreenOffset
GreenSlope
H(+H$
HardLight
HardMix
HeapAlloc
HeapFree
HeightMapInterpolationMode
HeightMapKernelSize
HeightMapScale
HueRotation
'i' is only supported with debug builds.
I$Rh0[
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeCriticalSectionEx
InitializeSListHead
inline float CalculateLitPixelDiffuse(minfloat3 surfaceNormal,
inline float EncodeReflectanceModelAndTransparentNormal(int reflectanceModel, minfloat4 normalHeight)
inline float GetSurfaceHeight(float4 normalHeight, float heightMapScale)
inline float3 CalculateBlinnPhongLitPixelSpecularUnpremultiplied(minfloat3 surfaceNormal,
inline float3 GetSurfaceNormal(float4 normalHeight)
inline float4 CalculateLitPixelSpecular(minfloat3 surfaceNormal,
inline minfloat D2DBlendAlpha(minfloat f, minfloat b)
inline minfloat D2DBlendColorDodgeComponent(minfloat f, minfloat b)
inline minfloat D2DBlendGetLuminosity(minfloat3 color)
inline minfloat D2DBlendHardMixComponent(minfloat f, minfloat b)
inline minfloat D2DBlendSafeDivision(minfloat f, minfloat b)
inline minfloat D2DBlendVividLightComponent(minfloat f, minfloat b)
inline minfloat3 D2DBlendApplyHueSatLum(minfloat3 hueSource, minfloat3 satSource, minfloat3 lumSource, minfloat3 lumFallback)
inline minfloat3 D2DBlendApplySourceLumToDest(minfloat3 dest, minfloat destSat, minfloat sourceLum)
inline minfloat3 D2DBlendBasicRgb(minfloat4 f, minfloat4 b, minfloat3 func)
inline minfloat3 D2DBlendColorBurnRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendColorDodgeRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDarkenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDarkerColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDifferenceRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDivisionRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendExclusionRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHardLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHardMixRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHueRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLightenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLighterColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearBurnRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearDodgeRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLuminosityRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendMultiplyRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendOverlayRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendPinLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSaturationRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendScreenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSoftLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSubtractRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendVividLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 RestrictGamut(minfloat3 colorRgb, minfloat luminance)
inline minfloat3 RgbToHsl(minfloat3 colorRgb)
inline minfloat4 D2DCompositeDestinationAtop(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationIn(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationOut(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationOver(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeMaskInvert(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositePlus(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceAtop(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceCopy(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceIn(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceOut(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceOver(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeXor(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DDistantDiffuse(float3 surfaceNormal, minfloat3 lightVector,
inline minfloat4 D2DDistantSpecular(float3 surfaceNormal, minfloat3 lightVector,
inline minfloat4 D2DGrayscale(minfloat4 color)
inline minfloat4 D2DPointDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DPointSpecular(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DSaturation(minfloat4 color, minfloat amount)
inline minfloat4 D2DSepiaPremultiplied(minfloat4 color, minfloat intensity)
inline minfloat4 D2DSepiaStraight(minfloat4 color, minfloat intensity)
inline minfloat4 D2DSpotDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DSpotSpecular(float3 surfaceNormal, minfloat3 pixelXY,
inline void PreparePointVectors(float3 pixelXY, float3 lightPosition,
inline void PrepareSpotVectors(float3 pixelXY,
InterlockedPushEntrySList
InternalName
InterpolationMode
Invalid animatable property mapping.
Invalid blur border mode.
Invalid effect input.
Invalid float value
invalid hash bucket count
Invalid number of sources.
invalid vector subscript
Invert
IsDebuggerPresent
IsProcessorFeaturePresent
jIntensity
K@;KDt
K4;K8t%
kernel32.dll
kernelbase.dll
L$(;L$,t
L$<_^[3
L$4^3
LeaveCriticalSection
LegalCopyright
length
lerp(
lib_4_0_level_9_3_ps_only
LightColor
LightCosConeAngle
Lighten
LighterColor
LightPosition
LightTargetVector
LightVector
LimitingConeAngle
LinearBurn
LinearDodge
LinearLight
LinearXfer
LoadLibraryW
LoadResource
Local\SM0:%lu:%lu:%hs
LockResource
LogHr
LogNt
lstd::exception: %hs
LuminanceToAlpha
Luminosity
LuminosityColor
LuminosityOpacity
M_>|~
Malformed animatable property name.
Malformed effect name.
Malformed named input name.
map/set too long
MaskInvert
Matrix
memcmp
memcpy
memmove
memset
Microsoft
Microsoft Composition Effects
Microsoft Corporation
Microsoft.Internal.UI.Composition.Effects.BlendEffect
Microsoft.Internal.UI.Composition.Effects.ColorSourceEffect
Microsoft.Internal.UI.Composition.Effects.OpacityEffect
minfloat
minfloat2
minfloat3
minfloat3x2
minfloat4
minfloat4 D2DColorMatrixPremultiplied(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
minfloat4 D2DColorMatrixStraight(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
minfloat4 D2DContrast(minfloat4 color, minfloat contrast)
minfloat4 D2DLuminanceToAlpha(minfloat4 color)
minfloat4 Premultiply(minfloat4 color)
minfloat4 UnPremultiply(minfloat4 color)
minfloat4x4
Msg:[%ws] 
msvcp_win.dll
Multiple animatable properties animate the same value.
Multiplier
Multiply
Multiply defined animatable property.
No more than four graph source parameters are supported.
No more than three graph source parameters with white noise effect are supported.
NOISE.HLSL
Noise.hlsl
Non-tree shaped effect graph.
ntdll.dll
NtQuerySystemInformation
NtQueryWnfStateData
NtUpdateWnfStateData
Null animatable property name.
Null effect input.
O8T>[
Offset
OLEAUT32.dll
onecore\internal\sdk\inc\wil\opensource/wil/resource.h
onecore\internal\sdk\inc\wil\Staging.h
onecoreuap\windows\dwm\common\shared\refcountbase.cpp
onecoreuap\windows\dwm\effects\compiler\effectgenerator.cpp
onecoreuap\windows\dwm\effects\compiler\effectinstance.cpp
onecoreuap\windows\dwm\effects\compiler\flattenedeffectgraph.cpp
onecoreuap\windows\dwm\effects\compiler\global\micabrushfactory.cpp
onecoreuap\windows\dwm\effects\compiler\graphicseffectgraphtraversal.cpp
onecoreuap\windows\dwm\effects\compiler\shaderincluderesolver.cpp
Opacity
OpenSemaphoreW
OriginalFilename
Output semantic can be changed only once.
Output_Normal_TangentSpace
OutputDebugStringW
Overlay
PinLight
PixelShader.hlsl
Pj;h8a
PointDiffuse
PointSpecular
PQQSVW
PQQVW
PQSVW
ProductName
ProductVersion
Property value out of bounds
PSBody
PSConstants
PVj h
qDh`W
Qj8VQ
QjsVQ
QQht^
QQSVW
QQSVW3
QQSVWj
QQVWj
QSVWh
QSVWj
QueryPerformanceCounter
qwGrayscale
RaiseException
RaiseFailFastException
RedAmplitude
RedDisable
RedExponent
RedOffset
RedSlope
ReflectanceModel
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
ResetEvent
return 
ReturnHr
ReturnNt
RoGetActivationFactory
RoOriginateError
RoOriginateErrorW
RoOriginateLanguageException
row_major 
RtlCaptureStackBackTrace
RtlDisownModuleHeapAllocation
RtlDllShutdownInProgress
RtlNotifyFeatureUsage
RtlNtStatusToDosErrorNoTeb
RtlQueryFeatureConfiguration
RtlRegisterFeatureConfigurationChangeNotification
RtlUnregisterFeatureConfigurationChangeNotification
sample
Saturation
SceneLighting
SceneLightingEffect cannot be a source to GaussianBlurEffect.
Screen
sDj<Y
Sepia
SerializeEffectDescription
SetEvent
SetLastError
SetThreadpoolTimer
SetUnhandledExceptionFilter
Sharpness
SizeofResource
SleepConditionVariableCS
SoftLight
SourceAtop
SourceCopy
SourceIn
SourceOut
SourceOver
Specified property cannot be animated.
Specified property does not exist or cannot be animated.
SpecularAmount
SpecularExponent
SpecularShine
SpotDiffuse
SpotSpecular
static const float3 c_defaultSurfaceNormal = float3(0.0f, 0.0f, 1.0f);
static const minfloat3 g_luminosityWeights = minfloat3(0.30, 0.59, 0.11);
static const minfloat3 grayFactor = minfloat3(0.2126, 0.7152, 0.0722);
static const minfloat4 c_defaultNormalHeight = minfloat4(0.5f, 0.5f, 1.0f, 1.0f);
string too long
StringFileInfo
Subtract
SVWRQ
T$@QQW
tAhtW
Temperature
TempTint
TerminateProcess
TerminateProcessOnMemoryExhaustion
TerminateThread
tFh$;
TintColor
TintOpacity
TransformMatrix
Translation
Tried to AddRef an object which has previously been freed (refcount went to 0).
u!hl?
u$h0^
u$hH^
u(h|`
u.PVh
u7SV3
u'h\^
uihh`
Unexpected effect input type.
Unexpected effect property value.
Unexpected property type.
Unexpected variable scope.
UnhandledExceptionFilter
Unknown exception
Unknown input parameter.
unordered_map/set too long
UnPremultiply(
Unrecognized response.
Unsupported alpha mode.
Unsupported blend mode.
Unsupported BorderEffect edge mode.
Unsupported composite mode.
Unsupported effect property type.
Unsupported effect type.
VarFileInfo
vector too long
VividLight
VS_VERSION_INFO
VVPhXd
VWjbZ
VWjkZ
VWQQ3
w hp>
w0hH>
WaitForSingleObject
WaitForSingleObjectEx
WaitForThreadpoolTimerCallbacks
WakeAllConditionVariable
Weight
WerRegisterMemoryBlock
WhiteNoise
WhiteNoise_XY
WilError_03
WilStaging_02
Windows.Foundation.PropertyValue
Windows.UI.Composition.CompositionEffectSourceParameter
WindowsCreateString
WindowsCreateStringReference
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
WindowsSubstringWithSpecifiedLength
winrt::hresult_error: %ls
WPQQV
WPWWV
wuceffects
wuceffects.dll
wuceffects.pdb
X[_^]
XAlphaMask
XForm
XYZ_Light0Space
Y__^[
YY_^]
