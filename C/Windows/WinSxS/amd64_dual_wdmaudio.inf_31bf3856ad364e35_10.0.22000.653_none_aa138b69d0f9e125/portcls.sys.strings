 !"#$%&'
 A^_]
 A^_^
 A_A^]
 A_A^_
 A_A^_^]
 A_A^A\
 A_A^A\_]
 A_A^A\_^
 A_A^A]A\_
 A_A^A]A\_^[
 A_A^A]A\_^]
 Microsoft Corporation. All rights reserved.
 MISMATCH
 Operating System
 Windows
!|$@H
!This program cannot be run in DOS mode.
#sCPortPinWaveRT::DistributeDeviceState
$;H(w
$D9w|t
(D$ H
(void) m_MiniportMXF->DisconnectOutput(m_CaptureSinkMXF)
(void) m_MiniportMXF->PutMessage(NULL)
(void) m_MiniportMXF->SetState(NewState)
)|wBK
)D$@A
)D$`A
)L$PA
)L$pD
* 4H`
.00cfg
.bss$06
.bss$dk00
.bss$dk06
.bss$pr00
.bss$pr01
.bss$pr06
.bss$zz
.data
.data$00
.data$06$brc
.data$dk00$brc
.data$dk01$brc
.data$dk06
.data$dk06$brc
.data$pr00
.data$pr00$brc
.data$pr06$brc
.data$zz
.data$zz$brc
.edata
.fffffff
.gehcont
.gfids
.giats
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.pdata
.rdata
.rdata$00
.rdata$00$brc
.rdata$01
.rdata$06
.rdata$06$brc
.rdata$brc
.rdata$PAGE$lp01portcls.sys!20_pri7
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zz$brc
.rdata$zzzdbg
.rsrc$01
.rsrc$02
.text
.text$lp00portcls.sys!20_pri7
.text$lp01portcls.sys!20_pri7
.text$lp06portcls.sys!50_coldboot
.text$mn
.text$mn$00
.text$mn$21
.text$np
.text$zy
.text$zz
.xdata
/M9.t<L
;A0sUH
;D$Pr
;D$Xs&A
;D$Xs5A
;J$sM
;tgfA;
?9iXu-H
?Rr<M
@8u0u?L
@8u0u'L
@A^_]
@A^_^
@A^A]A\
@A_A^_
@A_A^A\
@A_A^A\_^][
@A_A^A]A\_^]
@DA9AH
@HA9AD
@hvl~
@INIT
@LA9AP
@PA9AL
@SUVWAVH
@t fA
@USVWATAUAVAWH
@USVWH
@USWH
@UVWAVAWH
["[=[
["\:\{\
[%03X]
[@\o\
['\]\
[-\v]
[|]X^]_
[+[B[[\
[Filter::Close]
[Filter::Init]
[Function:calling]
[Function:returned]
[o\K]
[P]t]
[Pin::Close]
[Pin::DistributeDeviceState]
[Pin::Init]
[Port::Init]
[q\ ]
[RefCount:calling]
[RefCount:returned]
\!]3]
\!]F]K^
\"]I]4^^^
\#]4]t]
\$ E3
\$ UVWATAUAVAWH
\$ UVWH
\$(fD
\$8E3
\$8fD
\$pD;
\$xI9
\%];]
\1\d]+^
\Device\VerifierExt
\N\t\
\P\u\
\Registry\Machine\System\CurrentControlSet\Control\Class
\Registry\Machine\System\CurrentControlSet\Services\AudioSrv
]$C9"D
]:^P^b^
]2]J]
]V'XSZ
]w^:_u_
]X^y^
]Y]t]
^(^8^[^
^)_\_
^-^I^k^
^-_D_q_
__C_specific_handler
_<_P_
_L_n_
_purecall
_snwprintf
_streamNotification->FreeBufferWithNotification( *_pMDL, nextRequestedBufferSize)
_vsnwprintf
_wcsnicmp
` AWH
`.edata
`90`G
`A_A^A]_]
`A_A^A]A\_^]
`PAGEPcVfU+
`XQUY
{ ATAUAVH
{ AVH
{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
{146F1A80-4791-11D0-A5D6-28DB04C10000}
{53172480-4791-11D0-A5D6-28DB04C10000}
{642F5D00-4791-11D0-A5D6-28DB04C10000}
{pM9>t<L
|$ ATAVAWH
|$ AVH
|$ E3
|$ UATAUAVAWH
|$ UAVAWH
|$@fD
|$8E3
|$XA+
}8L9>
}HD9}T
}HD9uTv-H
+|$Pu
+Cx;C|
<unknown>
>{VP9
>v5]r
0;uTr
040904B0
0A^_]
0A^_^
0A_A]A\_^][
0A_A^]
0A_A^_
0A_A^A\
0A_A^A\_^
0A_A^A\_^[]
0A_A^A]A\_
0A_A^A]A\_^]
0VLVeV
0XYZAXAY
10.0.22000.653
10.0.22000.653 (WinBuild.160101.0800)
6PLP`P
8A^_^[
8A4tB
8fzIz^
8NiStatus = Miniport->GetPosition( PULONGLONG( &StreamTime ) )
8RrsI
9/%Wj
9:u|B
9_ t.H
9Chu*
9Mx1},
A 9B 
A D8@xu
A H9A(u
A!@`I
A$9B$
A(H9B(
A;H$sQA
A@H9AHu
A]A\_
A^A\_
A^A]_
A^A]A\
A_A\_
A_A]_
A_A]A\
A_A]A\_^
A_A^]
A_A^_
A_A^_^]
A_A^A\
A_A^A\_]
A_A^A\_^
A_A^A]
A_A^A]_]
A_A^A]_^
A_A^A]A\]
A_A^A]A\_
A_A^A]A\_^[
A_A^A]A\_^]
A_A^A]A\_^][
A8j)r
A8j)s
A8Z)s
A9} A
ACQUIRE
Ap9Al
Ap9Alu
APL9IHt
AQAPRQPH
AsrtH
Assert
assertVersion
AssertWER
AssertWithArgs
ATAVAWH
AUAVAWH
AXt=L
B.reloc
B.rsrc
B@D9A@u
B@H9A@
bGFIDS
Bp9Bl
bRich},
bucketArgument1
bucketArgument2
C Ic@lA;@pt=B
C(H9D$pt/H
C/!n1n
c\D8c8u5H
C<9E8s
C8;0u*E
Callee
Caller
CFeederInMXF::PutMessage
CFeederInMXF::SetState
CFeederOutMXF::ConsumeEvents
CFeederOutMXF::SetState
Class
CompanyName
ConservationIdleTime
CoreAudioBufferDuration
count
CPortClockWaveCyclic::GetCurrentPhysicalTime
CPortClockWaveCyclic::GetCurrentTime
CPortClockWaveCyclic::GetResolution
CPortClockWavePci::GetCurrentPhysicalTime
CPortClockWavePci::GetCurrentTime
CPortClockWavePci::GetResolution
CPortDMus::~CPortDMus
CPortDMus::DataRangeIntersection
CPortDMus::Init
CPortDMus::PinCount
CPortDMus::PowerChangeNotify
CPortDMus::ReleaseChildren
CPortDMus::RequestService
CPortFilterDMus::~CPortFilterDMus
CPortFilterDMus::Init
CPortFilterTopology::~CPortFilterTopology
CPortFilterTopology::Init
CPortFilterWaveCyclic::~CPortFilterWaveCyclic
CPortFilterWaveCyclic::Init
CPortFilterWavePci::~CPortFilterWavePci
CPortFilterWavePci::Init
CPortFilterWaveRT::~CPortFilterWaveRT
CPortPinDMus::~CPortPinDMus
CPortPinDMus::Close
CPortPinDMus::ConnectMXFGraph
CPortPinDMus::DeleteMXFGraph
CPortPinDMus::Init
CPortPinDMus::PowerNotify
CPortPinDMus::ServeCapture
CPortPinDMus::SetMXFGraphState
CPortPinTopology::~CPortPinTopology
CPortPinTopology::Init
CPortPinWaveCyclic::~CPortPinWaveCyclic
CPortPinWaveCyclic::Close
CPortPinWaveCyclic::GetPosition
CPortPinWaveCyclic::Init
CPortPinWaveCyclic::PowerNotify
CPortPinWaveCyclic::RequestService
CPortPinWaveCyclic::SetDeviceState
CPortPinWaveCyclic::SynchronizedSetFormat
CPortPinWavePci::~CPortPinWavePci
CPortPinWavePci::Close
CPortPinWavePci::GetPosition
CPortPinWavePci::Init
CPortPinWavePci::IrpSubmitted
CPortPinWavePci::MappingsCancelled
CPortPinWavePci::PinPropertyAllocatorFraming
CPortPinWavePci::PowerNotify
CPortPinWavePci::RequestService
CPortPinWavePci::SetDeviceState
CPortPinWaveRT::~CPortPinWaveRT
CPortPinWaveRT::Close
CPortPinWaveRT::GetKsAudioPosition
CPortPinWaveRT::Init
CPortTopology::~CPortTopology
CPortTopology::DataRangeIntersection
CPortTopology::GetPinName
CPortTopology::Init
CPortTopology::PinCount
CPortTopology::PnpStop
CPortTopology::PowerChangeNotify
CPortTopology::ReleaseChildren
CPortWaveCyclic::~CPortWaveCyclic
CPortWaveCyclic::DataRangeIntersection
CPortWaveCyclic::Init
CPortWaveCyclic::PinCount
CPortWaveCyclic::PowerChangeNotify
CPortWaveCyclic::ReleaseChildren
CPortWavePci::~CPortWavePci
CPortWavePci::DataRangeIntersection
CPortWavePci::Init
CPortWavePci::PinCount
CPortWavePci::ReleaseChildren
CPortWavePci::RequestService
CPortWaveRT::~CPortWaveRT
CPortWaveRT::Init
CPortWaveRT::PinCount
CPortWaveRT::PnpStop
CPortWaveRT::PowerChangeNotify
CPortWaveRT::ReleaseChildren
CRIM0
CXfD+
D!|$X
d$ E3
D$ E3
d$ E3
D$ E3
d$ E3
D$ E3
D$(D+
D$(E3
D$(f90t
D$(fD
D$@E3
D$@fD
D$`9^
d$`E8n@t
D$`fD
D$`Hc
D$0E3
d$0E3
D$0H+C8H
D$8fD
D$HE3
D$PD+
D$pE;
D$pE3
D$PE3
D$pE3
D$PE3
d$PE3
D$Pf!H
D$PfD
D$PH;
D$PHc
D$XE3
D$XH+
D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGWGX;;;LS)(A;;GRGWGX;;;IU)
D;{8t,H
D;ctu
D;kpu
D;L$Hr
D;RHt
D;RHu
D|$hI
D8{=u
D8a)s
D8A4t
D8Ayt
D8E(t
D8E)t
D8E'tQ
D8I)s
D8m@t
D8MHt
D8Q)r
D8q)s
D8Q)s
D9|$x
D9A@u
D9d$xH
D9d$xt
D9d$xu
D9w|u9L!
D9x u
D9x$u
DbgkWerCaptureLiveKernelDump
DCPortFilterWaveRT::Init
DCPortWaveRT::DataRangeIntersection
DeviceCharacteristics
DeviceExtensionSize should be either 0 or no less than PORT_CLASS_DEVICE_EXTENSION_SIZE.
DeviceType
DispatchSettings
DllInitialize
DllUnload
DMusic MPU-401 In 
DMusic MPU-401 Out 
DrmAddContentHandlers
DrmCreateContentMixed
DrmDestroyContent
DrmForwardContentToDeviceObject
DrmForwardContentToFileObject
DrmForwardContentToInterface
DrmGetContentRights
drmk.sys
E 9MH
E(+C8
E(H9]
E0D!U8H
E0f!H
E8!E(
E8J)s
E9E v5E
E9x u'D8{=u!H
E9x$u
E9Y0t
EF-7F
Enter Driver Start
Enter Driver Stop
en-US
EtwRegister
EtwRegisterClassicProvider
EtwSetInformation
EtwUnregister
EtwWriteTransfer
EventData
ExAcquireFastMutexUnsafe
ExAcquireSpinLockShared
ExAllocatePool2
ExAllocatePoolWithTag
Exclusive
ExEventObjectType
ExFreePoolWithTag
ExGetPreviousMode
Exit Driver Start
Exit Driver Stop
ExReleaseFastMutexUnsafe
ExReleaseSpinLockShared
ExSetTimerResolution
f9,Qu
f9AHu
f9Aju
f9AZu
f9iHu
f9qHu
f9QHu
f9qHu
f9QHu
f9qHu
f9yHE
f9yHu
f9YHu
f9yHu
f9YHu
f9yHu
f9YHu
f9yHu
f9YHu
f9yHu
f9YHu
f9yHu
f9YHu
f9yHu
f9YHu
f9yHu
f9yXu
f9yZu
fA9jHu
fA9rHu
fA9zHE
fA9ZHu
Failed CreatePortPinWaveRT from miniport
Failed to call miniport - Init
Failed to query interface from miniport
FAILED!
fD9#t
fD9$Cu
fD9/t
fD9`Hu
fD9+t
fD93t
fD94Bu
fD9aHu
fD9cjs
fD9iHu
fD9IHu
fD9iHu
fD9IHu
fD9iHu
fD9IHu
fD9iHu
fD9IHu
fD9iHu
fD9qHu
fD9't
fD9xHu
fD9yHu
fD9YHu
fD9yHu
fD9YHu
fD9yHu
fD9yhu
fD9yHu
fD9YHu
fD9yHu
fD9yju
fE94Gu
fE9jHu
fE9rHu
fffff
fffffff
-fffffff
FileDescription
FileVersion
G !plH
G !pp3
GD$0H
H VWAVH
H!\$@
H!|$ A
H!|$(D
H!}(H9>
H!t$ I
H!w(I
H.data
H.idata
h.rdata
H;D$0H
H;Jxt(H
H_^[]
H+K`H
H+K0H
H+S(H
H9]xt
'H9_`u!
H9_`u0E2
H9_hu
H9~`u
H9~xu
H99uAH
H9A u
H9-a"
H9A0u
H9A8u
H9C0uZ
H9D$xt$M
H9G t^
H9l$`tnH
H9Mxt#H
H9ohtt
H9Q t
H9Q(t
H9Q8t
H9QHE
H9QHt
H9s t:L
H9s@t:L
H9sxt:L
hA_A^A]A\_^[]
HAL.dll
HcC0L
HNONPAGE
i L9q
I+H`H
I+L$`H
i8L9q0
I9/u1
IcF0L
IdlePowerState
IgnoreErrors
imageName
ImagePath
imageSize
ImmediateIdle
imp_WppRecorderReplay
Information
InternalName
Interrupt
InterruptAffinity
IoAcquireRemoveLockEx
IoAllocateMdl
IoAllocateWorkItem
IoAttachDeviceToDeviceStack
IoBuildDeviceIoControlRequest
IoBuildPartialMdl
IoBuildSynchronousFsdRequest
IoConnectInterrupt
IoCreateDevice
IoCreateDeviceSecure
IoDeleteDevice
IoDetachDevice
IoDeviceObjectType
IoDisconnectInterrupt
IofCallDriver
IofCompleteRequest
IoFileObjectType
IoFreeMdl
IoFreeWorkItem
IoGetCurrentProcess
IoGetDeviceObjectPointer
IoGetDeviceProperty
IoGetDmaAdapter
IoInitializeRemoveLockEx
IoInitializeTimer
IoIsWdmVersionAvailable
IoOpenDeviceInterfaceRegistryKey
IoOpenDeviceRegistryKey
IoQueueWorkItem
IoRegisterDeviceInterface
IoReleaseRemoveLockAndWaitEx
IoReleaseRemoveLockEx
IoReportTargetDeviceChangeAsynchronous
IoSetDeviceInterfaceState
IoStartTimer
IoSteerInterrupt
IoStopTimer
IoValidateDeviceIoControlAccess
IoWMIRegistrationControl
IoWMIWriteEvent
IPort::GetDeviceProperty should only be called at IRQL == PASSIVE_LEVEL.
IPort::Init should only be called at IRQL == PASSIVE_LEVEL.
IPort::NewRegistryKey should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::AllocateContiguousPagesForMdl has invalid parameter on TotalBytes.
IPortWaveRTStream::AllocateContiguousPagesForMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::AllocatePagesForMdl has invalid parameter on TotalBytes.
IPortWaveRTStream::AllocatePagesForMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::FreePagesFromMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::GetPhysicalPageAddress should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::GetPhysicalPagesCount should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::MapAllocatedPages cannot accept a NULL MDL.
IPortWaveRTStream::MapAllocatedPages should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::MapAllocatedPages: the CacheType can only be MmNonCached, MmCached or MmWriteCombined.
IPortWaveRTStream::UnmapAllocatedPages should only be called at IRQL == PASSIVE_LEVEL.
IRP_MN_CANCEL_REMOVE_DEVICE
IRP_MN_CANCEL_STOP_DEVICE
IRP_MN_EJECT
IRP_MN_FILTER_RESOURCE_REQUIREMENTS
IRP_MN_PAGING_NOTIFICATION
IRP_MN_QUERY_BUS_INFORMATION
IRP_MN_QUERY_CAPABILITIES
IRP_MN_QUERY_DEVICE_RELATIONS
IRP_MN_QUERY_DEVICE_TEXT
IRP_MN_QUERY_ID
IRP_MN_QUERY_INTERFACE
IRP_MN_QUERY_PNP_DEVICE_STATE
IRP_MN_QUERY_REMOVE_DEVICE
IRP_MN_QUERY_RESOURCE_REQUIREMENTS
IRP_MN_QUERY_RESOURCES
IRP_MN_QUERY_STOP_DEVICE
IRP_MN_READ_CONFIG
IRP_MN_REMOVE_DEVICE
IRP_MN_SET_LOCK
IRP_MN_START_DEVICE
IRP_MN_STOP_DEVICE
IRP_MN_SURPRISE_REMOVAL
IRP_MN_UNKNOWN_0x0e
IRP_MN_WRITE_CONFIG
K::If
KeAcquireSpinLockAtDpcLevel
KeAcquireSpinLockRaiseToDpc
KeCancelTimer
KeClearEvent
KeEnterCriticalRegion
KeGetCurrentIrql
KeGetRecommendedSharedDataAlignment
KeInitializeDpc
KeInitializeEvent
KeInitializeMutex
KeInitializeSpinLock
KeInitializeTimer
KeInsertQueueDpc
KeLeaveCriticalRegion
KeLowerIrql
KeQueryActiveProcessorCountEx
KeQueryGroupAffinity
KeQueryPerformanceCounter
KeQueryTimeIncrement
KeReleaseMutex
KeReleaseSpinLock
KeReleaseSpinLockFromDpcLevel
KeRemoveQueueDpc
KeSetEvent
KeSetSelectedCpuSetsThread
KeSetTimer
KeSetTimerEx
KeStackAttachProcess
KeStallExecutionProcessor
KeSynchronizeExecution
KeUnstackDetachProcess
KeWaitForMultipleObjects
KeWaitForSingleObject
KEYWD
KfRaiseIrql
KH!|$(L
kpH9kxt6L
ks.sys
KsAcquireResetValue
KsAddIrpToCancelableQueue
KsAddObjectCreateItemToDeviceHeader
KsAllocateDeviceHeader
KsAllocateObjectHeader
KsCancelIo
KsCancelRoutine
KsCreateDefaultAllocator
KsDefaultDeviceIoCompletion
KsDereferenceSoftwareBusObject
KsDisableEvent
KsDispatchInvalidDeviceRequest
KsDispatchIrp
KsEnableEvent
KsFreeDeviceHeader
KsFreeEventList
KsFreeObjectHeader
KsGenerateEvent
KsoOH
KsPinDataIntersection
KsPinPropertyHandler
KsProbeStreamIrp
KsPropertyHandler
KsReferenceSoftwareBusObject
KsReleaseIrpOnCancelableQueue
KsRemoveIrpFromCancelableQueue
KsRemoveSpecificIrpFromCancelableQueue
KsSetDevicePnpAndBaseObject
KsSetMajorFunctionHandler
KsSynchronousIoControlDevice
KsTopologyPropertyHandler
KsValidateClockCreateRequest
KsValidateConnectRequest
L!|$ H
l$ E3
L$ E3
L$ SUVWATAUAVAWH
L$ SUVWATAUAWH
L$ SVWAVH
L$ UH
L$ UVWATAUAVAWH
l$ VWATAVAWH
l$ VWAVH
L$@H!\$@
L$@H3
L$`A+
L$`E3
L$0E3
L$0H+K@H
L$0H3
l$0IcA0= 
l$8D;
L$8E3
l$8fD
L$8fD
l$8fD
L$8fD
l$8fD
L$HA;
L$HH3
L$hH3
L$HH3
l$PA+
L$PE3
L$pH3
L$PH3
L$pH3
L$PH3
L$pH3
l$XA+
L$XE3
L$XH3
L$XH9Y@u=H
L+A0A
L+A0L
L9%!^
L9%>Z
L9%1F
L9%bE
L9%E_
L9%f$
L9%h;
L9%K`
L9%V#
L9%w\
L9.t4L
L9/t4L
L9{pt>L
L9}8t
L9=_h
L9=Di
L9=M 
L9=q'
L9-2e
L95fk
L9A0t
L9bhu
L9c8t
L9e0u
L9-G2
L9IHt
L9l$pt_I
L9s8t
L9-UH
Leaking resources allocated by IPortWaveRTStream::AllocatePagesForMdl/AllocateContiguousPagesForMdl.
LegalCopyright
LEVL@
m_IrpStream->Release()
m_Miniport->AddRef()
m_Miniport->Release()
m_Miniport->Service()
m_MiniportMidiStream->Release()
m_MiniportMXF->Release()
m_MiniportMXF->SetState(KSSTATE_ACQUIRE)
m_MiniportMXF->SetState(KSSTATE_PAUSE)
m_MiniportMXF->SetState(m_DeviceState)
m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible)
m_MPPinCountI->Release()
m_MPPinNameI->Release()
m_pIAudioEngine->Release()
m_Stream->Release()
m_Stream->SetNotificationFreq( WAVECYC_NOTIFICATION_FREQUENCY, &m_FrameSize )
m_Stream->SetState(KSSTATE_ACQUIRE)
m_Stream->SetState(KSSTATE_PAUSE)
m_Stream->SetState(KSSTATE_STOP)
m_Stream->SetState(m_DeviceState)
m_Stream->Silence( m_DmaChannel->SystemAddress(), m_ulDmaCopy + ulBytesToSilence - ulDmaBufferSize )
m_Stream->Silence( PVOID(PUCHAR(m_DmaChannel->SystemAddress()) + m_ulDmaCopy), ulBytesToSilence)
m_Stream->Silence(m_DmaChannel->SystemAddress(),m_DmaChannel->BufferSize())
M9/t<L
M9}8t
message
Microsoft
Microsoft Corporation
Microsoft.Windows.Audio.PortClass
Miniport->AddRef()
Miniport->Release()
Miniport->Service()
MmAddVerifierSpecialThunks
MmAddVerifierThunks
MmAllocatePagesForMdl
MmAllocatePagesForMdlEx
MmAreMdlPagesCached
MmBuildMdlForNonPagedPool
MmFreePagesFromMdl
MmGetSystemRoutineAddress
MmIsDriverVerifying
MmIsVerifierEnabled
MmLockPagableDataSection
MmMapLockedPagesSpecifyCache
mmres.dll
MmUnlockPagableImageSection
MmUnmapLockedPages
MOFDATA
MXF H
MXFbH
MXFpH
NewState
NoDisplayClass
NONPAGE
NoUseClass
NPI9^
ntoskrnl.exe
NTStatus
ntStatus
NTStatus
ntStatus
ntStatus = _streamNotification->AllocateBufferWithNotification( _notificationCount, finalRequestBufferSize, _pMDL, &returnBufferSize, _pOffsetFromFirstPag, _pCacheType )
ntStatus = _streamNotification->AllocateBufferWithNotification( _notificationCount, nextRequestedBufferSize, _pMDL, &returnBufferSize, _pOffsetFromFirstPag, _pCacheType )
ntStatus = m_Miniport->DataRangeIntersection( PinId, DataRange, MatchingDataRange, OutputBufferLength, ResultantFormat, ResultantFormatLength)
ntStatus = m_Miniport->GetDescription(&m_pPcFilterDescriptor)
ntStatus = m_Miniport->Init( UnknownAdapter, ResourceList, PPORTDMUS(this), &pServiceGroup)
ntStatus = m_MiniportMXF->ConnectOutput(m_CaptureSinkMXF)
ntStatus = m_MiniportStream->SetState(State)
ntStatus = m_MiniportStream->Write(aDMKEvt->uData.abData + byteOffset,bytesRemaining,&bytesWritten)
ntStatus = m_MiniportStream->Write(aDMKEvt->uData.pbData + byteOffset,bytesRemaining,&bytesWritten)
ntStatus = m_MPPinNameI->GetPinName(_pIrp,_pKsPPin,_pvData)
ntStatus = m_Port->m_Miniport->NewStream( &m_MiniportMXF, NULL, NonPagedPoolNx, m_Id, m_StreamType, m_DataFormat, &(m_ServiceGroup), (PAllocatorMXF)m_AllocatorMXF, (PMASTERCLOCK)this->m_Port, &SchedulePreFetch )
ntStatus = m_Port->m_MiniportMidi->NewStream( &m_MiniportMidiStream, NULL, NonPagedPoolNx, m_Id, m_StreamType == DMUS_STREAM_MIDI_CAPTURE ? TRUE : FALSE, m_DataFormat, &(m_ServiceGroup) )
ntStatus = m_Port->Miniport->NewStream( &m_Stream, NULL, NonPagedPoolNx, m_Id, m_DataFlow == KSPIN_DATAFLOW_OUT, m_DataFormat, &m_DmaChannel, &m_ServiceGroup )
ntStatus = m_Stream->GetPosition(&ulDmaPosition)
ntStatus = m_Stream->SetFormat(inDataFormat)
ntStatus = m_Stream->SetState(NewState)
ntStatus = Miniport->DataRangeIntersection( PinId, DataRange, MatchingDataRange, OutputBufferLength, ResultantFormat, ResultantFormatLength )
ntStatus = Miniport->GetDescription(&m_pPcFilterDescriptor)
ntStatus = Miniport->GetDeviceDescription (&m_DeviceDescription)
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTTOPOLOGY(this))
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVECYCLIC(this) )
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVEPCI(this), &ServiceGroup )
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVERT(this) )
ntStatus = Port->Miniport->NewStream ( &Stream, NULL, NonPagedPoolNx, PPORTWAVEPCISTREAM(this), Id, Descriptor->DataFlow == KSPIN_DATAFLOW_OUT, DataFormat, &DmaChannel, &ServiceGroup )
ntStatus = Port->Miniport->NewStream ( &Stream, PPORTWAVERTSTREAM(this), Id, Descriptor->DataFlow == KSPIN_DATAFLOW_OUT, DataFormat )
ntStatus = Stream->SetState(KSSTATE_ACQUIRE)
ntStatus = Stream->SetState(KSSTATE_PAUSE)
ntStatus = Stream->SetState(KSSTATE_STOP)
ntStatus = Stream->SetState(m_DeviceState)
ntStatus = Stream->SetState(NewState)
ntStatus = that->Stream->AllocateAudioBuffer (property->RequestedBufferSize, &that->rt.AudioBuffer.Mdl, &bufferSize, &byteOffset, &cacheType)
ntStatus = that->Stream->GetClockRegister (mapping)
ntStatus = that->Stream->GetPositionRegister (mapping)
ntStatus = that->Stream->SetFormat(FilteredDataFormat)
ntStatus = that->StreamInput->GetReadPacket(&value->PacketNumber, &value->Flags, &value->PerformanceCounterValue, &value->MoreData)
ntStatus = that->StreamNotification->AllocateBufferWithNotification( that->rt.NotificationCount, propertyNotification->RequestedBufferSize, &that->rt.AudioBuffer.Mdl, &bufferSize, &byteOffset, &cacheType )
ntStatus = that->StreamNotification->RegisterNotificationEvent( pNewEntry->pNotificationEvent )
ntStatus = that->StreamNotification->UnregisterNotificationEvent( pRemovedEvent->pNotificationEvent )
ntStatus = that->StreamOutput->GetOutputStreamPresentationPosition(value)
ntStatus = that->StreamOutput->GetPacketCount(packetCount)
ntStatus = that->StreamOutput->SetWritePacket(value->PacketNumber, value->Flags, value->EosPacketLength)
ntStatus= Stream->GetPosition(&pIrpStreamPosition->ullStreamPosition)
ntStatus2 = m_MiniportStream->Read(aMidiData,sizeof(PBYTE),&bytesRead)
ntStatus2 = that->Stream->SetState(KSSTATE_PAUSE)
ntStatus2 = that->Stream->SetState(KSSTATE_RUN)
O`fA;
O8H9Q
ObfDereferenceObject
ObfReferenceObject
ObOpenObjectByPointer
ObReferenceObjectByHandle
OldState
OPCOp
OriginalFilename
originatingBinary
p AWH
p WATAUAVAWH
p WAVAWH
P,QRQ`R
P,SeS
P:PyPJQkQ
-P>PTPyP{Q
P5P~P
P5PPPzP
P8QcQ
pA^_]
PA^_]
PA^_^][
PA_A^]
PA_A^_
PA_A^_^]
pA_A^A]A\^[]
PA_A^A]A\_^]
pA_A^A]A\_^]
PAGE$lp00portcls.sys!20_pri7
PAGE$lp01portcls.sys!20_pri7
PAGE$lp06portcls.sys!50_coldboot
PAGE$np
PAGE$zy
PAGE$zz
PAGEPcVf$zz
PAUSE
PcAddAdapterDevice
PcAddAdapterDevice should only be called at IRQL == PASSIVE_LEVEL.
PcAddContentHandlers
PcAddContentHandlers should only be called at IRQL == PASSIVE_LEVEL.
PcAddStreamResource
PcAssignPowerFrameworkSettings
PcCiH
PcCompleteIrp
PcCompleteIrp should only be called at IRQL <= DISPATCH_LEVEL.
PcCompletePendingPropertyRequest
PcCompletePendingPropertyRequest should only be called at IRQL <= DISPATCH_LEVEL.
PcCompletePendingPropertyRequest shouldn't be called with an NtStatus value of STATUS_PENDING.
PcCrA
PcCreateContentMixed
PcCreateContentMixed should only be called at IRQL == PASSIVE_LEVEL.
PcCrH
PcDestroyContent
PcDestroyContent should only be called at IRQL == PASSIVE_LEVEL.
PcDfA
PcDispatchIrp
PcDispatchIrp should only be called at IRQL == PASSIVE_LEVEL.
PcDWH
PcEiH
PcErH
PcEtH
PcForwardContentToDeviceObject
PcForwardContentToDeviceObject should only be called at IRQL == PASSIVE_LEVEL.
PcForwardContentToFileObject
PcForwardContentToFileObject should only be called at IRQL == PASSIVE_LEVEL.
PcForwardContentToInterface
PcForwardContentToInterface should only be called at IRQL == PASSIVE_LEVEL.
PcForwardIrpSynchronous
PcForwardIrpSynchronous should only be called at IRQL == PASSIVE_LEVEL.
PcGetContentRights
PcGetContentRights should only be called at IRQL == PASSIVE_LEVEL.
PcGetDeviceProperty
PcGetDeviceProperty should only be called at IRQL == PASSIVE_LEVEL.
PcGetPhysicalDeviceObject
PcGetTimeInterval
PcIcH
PcInitializeAdapterDriver
PcInitializeAdapterDriver : Invalid Parameter.
PcInitializeAdapterDriver should only be called at IRQL == PASSIVE_LEVEL.
PcIsH
PcKdA
PcKdH
PcLNf
PcMqH
PcNewDmaChannel
PcNewDmaChannel should only be called at IRQL == PASSIVE_LEVEL.
PcNewInterruptSync
PcNewInterruptSync should only be called at IRQL == PASSIVE_LEVEL.
PcNewMiniport
PcNewMiniport should only be called at IRQL == PASSIVE_LEVEL.
PcNewPort
PcNewPort should only be called at IRQL == PASSIVE_LEVEL.
PcNewRegistryKey
PcNewRegistryKey should only be called at IRQL == PASSIVE_LEVEL.
PcNewResourceList
PcNewResourceList should only be called at IRQL == PASSIVE_LEVEL.
PcNewResourceSublist
PcNewResourceSublist should only be called at IRQL == PASSIVE_LEVEL.
PcNewServiceGroup
PcNewServiceGroup should only be called at IRQL == PASSIVE_LEVEL.
PcNt9Q
PcNtL
PcNttmL
PcPrA
PcPrH
PcRegisterAdapterPnpManagement
PcRegisterAdapterPowerManagement
PcRegisterAdapterPowerManagement should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterIoTimeout
PcRegisterPhysicalConnection
PcRegisterPhysicalConnection should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterPhysicalConnectionFromExternal
PcRegisterPhysicalConnectionFromExternal should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterPhysicalConnectionToExternal
PcRegisterPhysicalConnectionToExternal should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterSubdevice
PcRegisterSubdevice should only be called at IRQL == PASSIVE_LEVEL.
PcRemoveStreamResource
PcRequestNewPowerState
PcRequestNewPowerState should only be called at IRQL == PASSIVE_LEVEL.
PcRLH
PcRlI
PcRMH
PcRPH
PcRtH
PcRvH
PcSbA
PcSiH
PcSlI
PcSrH
PcStH
PcUnregisterAdapterPnpManagement
PcUnregisterAdapterPowerManagement
PcUnregisterAdapterPowerManagement should only be called at IRQL == PASSIVE_LEVEL.
PcUnregisterIoTimeout
PcUsH
PEP7QeQ
PerformanceIdleTime
pIMiniportAudioSignalProcessing->Release()
PinPropertyDataFormat
PinPropertyGetAudioBuffer
PinPropertyGetClockRegister
PinPropertyGetHWLatency
PinPropertyGetPositionRegister
PinPropertyHandler_GetOutputStreamPresentationPosition
PinPropertyHandler_GetPacketCount
PinPropertyHandler_GetReadPacket
PinPropertyHandler_SetWritePacket
PinPropertyNotificationEvent
PinPropertyPosition
pMiniportPnpNotify->PnpStop()
PoCallDriver
PoClearPowerRequest
PoCreatePowerRequest
PoDeletePowerRequest
PoFxActivateComponent
PoFxCompleteDevicePowerNotRequired
PoFxCompleteDirectedPowerDown
PoFxCompleteIdleCondition
PoFxCompleteIdleState
PoFxIdleComponent
PoFxPowerControl
PoFxRegisterDevice
PoFxReportDevicePoweredOn
PoFxSetDeviceIdleTimeout
PoFxStartDevicePowerManagement
PoFxUnregisterDevice
PoRegisterPowerSettingCallback
PoRequestPowerIrp
Port Class (Class Driver for Port/Miniport Devices)
PortCls
Portcls
portcls.pdb
portcls.sys
Portcls/Analytic
Portcls/Operational
Portcls/Performance
Portcls_Device_Initialization
Portcls_Device_Read
Portcls_Device_Stop
Portcls_Device_Write
PORTCLSMOF
PortclsMof
PoSetPowerRequest
PoSetPowerState
PoStartNextPowerIrp
PoUnregisterPowerSettingCallback
PowerSettings
pP\QLRjS
pPowerNotify->PowerChangeNotify( PowerState )
pPowerNotify->PowerChangeNotify(PowerState)
pPowerNotify->Release()
PPR~V
PpRbH
P-QnQYV
PQT?U
ProbeForRead
ProductName
ProductVersion
Properties
PRVA$
PsGetVersion
PUNKNOWN(pMiniportPnpNotify)->Release()
PXQEWIXLZ,[1]
Q R2RGS
Q$S[S
Q%QKQ
Q(H9Zht
Q,QcQ
Q.RtR-SSS
Q?QoQ
Q+RgRxR
QpMiniportAudioSignalProcessing->Release()
QptmH
R$fA;Z*
R@R2T
RefCount
Resolution->Granularity = Miniport->NormalizePhysicalPosition( &OneByte )
ResourceSet
Response Time
RetryAllocateBufferWithNotification
RNR[V
RtlAbsoluteToSelfRelativeSD
RtlAddAccessAllowedAce
RtlCompareUnicodeString
RtlCreateSecurityDescriptor
RtlFreeAnsiString
RtlFreeUnicodeString
RtlGetDaclSecurityDescriptor
RtlGetGroupSecurityDescriptor
RtlGetOwnerSecurityDescriptor
RtlGetSaclSecurityDescriptor
RtlInitAnsiString
RtlInitUnicodeString
RtlLengthSecurityDescriptor
RtlLengthSid
RtlQueryRegistryValues
RtlQueryRegistryValuesEx
RtlSetDaclSecurityDescriptor
RtlUnicodeStringToAnsiString
s AWH
s D9u
S`H9*u
S>SpS
S6TuT
S9SWS
SeAccessCheckWithHint
SeAlA
SeCaptureSecurityDescriptor
SeCaptureSubjectContext
SeConvertStringSecurityDescriptorToSecurityDescriptor
Security
SeExports
SeReleaseSubjectContext
SeSdH
SeTsI
ShD9Sd
SHUvU
SingleComponentMultiFxStates
SKT~T
SoS5T%UlV
S'T~T
Start
state
Status
status
Status = Miniport->GetPosition( PULONGLONG( &PhysicalTime ))
Status = Miniport->NormalizePhysicalPosition( &PhysicalTime )
Status = Miniport->NormalizePhysicalPosition( &StreamTime )
status = Stream->SetState(state)
Status = WavePciPin->Stream->GetAllocatorFraming( AllocatorFraming )
Stream->FreeAudioBuffer (rt.AudioBuffer.Mdl, rt.AudioBufferSize)
Stream->GetPosition( &ullCurrentPosition )
Stream->GetPosition(&m_ullStreamSleepPosition)
Stream->GetPosition(pKsAudioPosition)
Stream->MappingAvailable()
Stream->Release()
Stream->RevokeMappings(FirstTag, LastTag, MappingsCancelled)
Stream->Service()
StreamInput->Release()
StreamNotification->FreeBufferWithNotification( rt.AudioBuffer.Mdl, rt.AudioBufferSize )
StreamNotification->Release()
StreamNotification->UnregisterNotificationEvent( pCurrentEntry->pNotificationEvent )
StreamOutput->Release()
StringFileInfo
SUVWATAUAVAWH
SUVWATAVAWH
SVWATAUAVAWH
t$ AWH
t$ E3
T$ E3
T$ H;
t$ UH
t$ UWATAVAWH
t$ UWAWH
t$ WATAUAVAWH
t$ WAVAWH
t$ WH
t$(E3
T$@E3
t$@fD
T$`;n
T$8fD
t$8fD
T$8fD
t%H9X
t)H+Q
T.UYU
t?H9kxt9L
t[9D$pD
t[H9s
t|H9s
t+D8@
t1L9r
T5UjU
T6TOTyT
t7fA9P
t8H9q
ta9{$r\
tAH9w
TASKD
TELASSERT
TelemetryAssert
TelemetryAssertDiagTrack
TelemetryAssertDiagTrack_KM
tgH!D$pM
t-H9Y
that->Stream->FreeAudioBuffer (that->rt.AudioBuffer.Mdl, bufferSize)
that->Stream->FreeAudioBuffer( that->rt.AudioBuffer.Mdl, bufferSize )
that->Stream->FreeAudioBuffer(that->rt.AudioBuffer.Mdl, bufferSize)
that->Stream->GetHWLatency (hwLatency)
that->Stream->MappingAvailable()
that->StreamNotification->FreeBufferWithNotification( that->rt.AudioBuffer.Mdl, bufferSize )
The MDL has been mapped already.
The MDL isn't unmapped before free.
The miniport driver should not call PoRequestPowerIrp with IRP_MN_SET_POWER.
The unmapped BaseAddress doesn't match the MDL.
This device is already registered by PcRegisterAdapterPowerManagement.
This device is not registered by PcRegisterAdapterPowerManagement.
Thread
tIL!|$pM
Timeout on state transition by AVStrMiniPinSetDeviceState.
Timeout on state transition from KSSTATE_PAUSE to KSSTATE_RUN by AVStrMiniPinSetDeviceState.
Timeout on state transition from KSSTATE_STOP to KSSTATE_ACQUIRE by AVStrMiniPinSetDeviceState.
timestamp
tJH9q@t/H
TNT&VLVkV
totalHits
TP[,\
tr!L$<H
Translation
tu!L$<H
tVHcC0L
tVL9*t
TvTiV
tW;*sSH
TXUuVBW
u A9J
U%VPV
U(VJV
U)V\V
u*!Q4!Q0H!Q H!Q(3
u:fA9XZt3A
u;D9cht(H
U;VuV
u[f9kjtU
u0@8k=u
u0fD;
U2Y+Zz\
UATAUAVAWH
UAVAWH
UAVAWI
uD@8{=u
ulRefCount = m_Miniport->Release()
ulRefCount = m_MiniportMXF->Release()
Unknown
UNKNOWN
UsePositionLock
USVATAUAVAWH
USVWATAVAWH
UUV~V
UVWATAUAVAWH
UVWAVAWH
UWATAVAWH
UWAUAVAWH
UWAVH
UWAWH
UZV$W
V"WcWhX
V%WKWmW}WlX
v(9^$
V:VtV
VarFileInfo
VJW7X
vo"Z6jwS
VS_VERSION_INFO
VWATAUAWH
VWATAVAWH
VWAUAVAWH
VWAVH
V'WeW
V'WoW
W!XIX
W}XX\
W8WrW
WATAUAVAWH
WATAUH
WATAVH
WATAWH
WAUAVH
WAUAWH
WAVAWH
wcschr
WEVT_TEMPLATE
WEYhY
win:Informational
win:ResponseTime
win:Start
win:Stop
WmiCompleteRequest
WMILIB.SYS
WmiQueryTraceInformation
WmiSystemControl
WmiTraceMessage
WMXkX
WpH9_h
WppAutoLogStart
WppAutoLogStop
WppAutoLogTrace
WppRecorder.sys
wx;CDt
WXXzX
W'ZZZ
x ATAUAVH
x ATAUAWH
x ATAVAWH
x AUAVAWH
x AVH
x UATAUAVAWH
X#YYY
X:Z|Z
X@XoX
XA_A^A]A\_^[]
XA_A^A]A\_^][
XdvTimedFactor
XKYzY
xN9{hu*E3
Y"Z?ZdZ
Y5ZJZ
YDYaY
YFY/ZaZI[|[
YptrH
YTZiZ
Z"ZpZ
Z\^?_
Z>[Z[
Zl[&]
zpL1^0
zPMeSsk
ZwClose
ZwCreateKey
ZwDeleteKey
ZwEnumerateKey
ZwEnumerateValueKey
ZwOpenKey
ZwQueryKey
ZwQueryValueKey
ZwSetSecurityObject
ZwSetValueKey
