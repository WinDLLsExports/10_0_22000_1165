 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHI
 A_A^_
 A_A^A\
 A_A^A]A\_
 A_A^A]A\_^]
 H3E H3E
 Microsoft Corporation. All rights reserved.
 Operating System
 Windows
!|$dH
!|$lH
!T$ E3
!t$`H
!This program cannot be run in DOS mode.
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%u)\%hs!%p: 
(caller: %p) 
.?AVexception@std@@
.?AVResultException@wil@@
.?AVtype_info@@
.00cfg
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.data
.data$brc
.data$r$brc
.data$rs$brc
.edata
.gehcont
.gfids
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.pdata
.rdata
.rdata$brc
.rdata$r
.rdata$zETW2
.rdata$zzzdbg
.rsrc$01
.rsrc$02
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.xdata
.xdata$x
:hu/H
@.data
@.reloc
@.rsrc
@A^_^
@A_A^_
@A_A^A\
@A_A^A\_^[]
@SUVWATAUAVAW
@SUVWH
@SVWH
@USVWATAUAVAWH
@USVWATAVAWH
@USVWAVH
@UVWATAUAVAWH
@UVWAVAWH
@VWATAVAWH
[%hs(%hs)]
[%hs]
\$ UH
\$ UVWATAUAVAWH
\$ UVWH
\$ VWAVH
\$8H;
\\.\VmSwitch
__C_specific_handler
__current_exception
__current_exception_context
__CxxFrameHandler3
_CxxThrowException
_initterm
_initterm_e
_o___std_exception_copy
_o___std_exception_destroy
_o___std_type_info_destroy_list
_o___stdio_common_vsnprintf_s
_o___stdio_common_vswprintf
_o__cexit
_o__configure_narrow_argv
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__invalid_parameter_noinfo_noreturn
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o_free
_o_qsort
_o_terminate
` UAVAWH
`.rdata
`A_A^A]A\_^]
|$ AVH
|$0E3
|$hfD
}0H+}(H
<===== DeInitializing IOCTL operation
=====> Initialized IOCTL 0x%x, DriverHandle=0x%p, IsOverlappedHandle=%d
=====> ReInitialize IOCTL 0x%x, DriverHandle=0x%p, IsOverlappedHandle=%d
040904B0
0A_A^_
0A_A^A\_^
0A_A^A]A\_
10.0.22000.832
10.0.22000.832 (WinBuild.160101.0800)
8_^][
8A^_^[
97tKA
A^_^[]
A_A^]
A_A^_
A_A^_^]
A_A^A\
A_A^A\_]
A_A^A\_^[]
A_A^A]
A_A^A]A\]
A_A^A]A\_
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
A8]8t
AcquireSRWLockExclusive
AcquireSRWLockShared
Allows host vNic to indicate packets using L2 indirection table
Allows user to configure global variable using the ioctl interface.
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
C D8U@u
C9fD9?u-
CallContext:[%hs] 
Can bypass extensibility stack for host vNICs
Can isolate untrusted VMs from cache attacks on host
Can perform dynamic VMMQ steering using RSSv2
Can perform packet monitoring
Can perform Software RSC over physical NIC
Can support independent host spreading when RSS is disabled in guest
Can support suspended live migration for port redirection
Can track where packets have been within vmswitch
CHfA;
CLH!t$0
CloseHandle
CloseThreadpoolTimer
CompanyName
Context=0x%p, IOCTL=0x%x, LegacyInfo=%p, InputBuffer=0x%p, InputBufferSize=%d, OutputBuffer=0x%p, OutputBufferSize=%d
CreateEventA
CreateFileW
CreateMutexExW
CreateSemaphoreExW
CreateThreadpoolTimer
D$ D+
D$ E3
D$(E3
D$(fD
D$,D8-
D$@E3
D$\L%
D$`fB
D$0E3
D$0fD
d$0fD
D$0H;
D$0H+
D$HE3
D$hfE
D$p!|$HD+
D$p+\$`A
D$p+\$`L
D$p+|$`
D$p+|$`L
D$PE;
D$xE3
D+D$x
D+D$xD
D9|$(
D9ILs
D9l$(|
D9u`H
DebugBreak
DeleteCriticalSection
DeviceIoControl
E8<8u
ElementVariableBufferSize=%d
EnterCriticalSection
EventRegister
EventSetInformation
EventUnregister
Exception
f9,Cu
f94Au
fA9,@u
fA94@u
Failed to allocate memory for input buffer with size %d
Failed to create event for overlapped object. error=%d
Failed to query vmswitch capabilities, expected for TH, non-AZURE RS1, or RS2..RS3 vmswitch. Initializing VMSIF with no vmswitch capabilities. Status=0x%x
FailFast
fD9>u$H
fF94Fu
FileDescription
FileVersion
FormatMessageW
GenuD
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetLastError
GetModuleFileNameA
GetModuleHandleExW
GetModuleHandleW
GetOverlappedResult
GetProcAddress
GetProcessHeap
GetSystemTimeAsFileTime
GetVersionExW
H UATAUAVAWH
h UAVAWH
h VWAVH
H!\$0H
H!\$8I
H!_(H!_0H!_8H!_@M
H!|$@
H!|$8E3
H!|$8H
H9oHsKH
H9p uH
Handles NrtNameResolutionId in NBLs
HcD$$H
HcL$ H
HD!D$H
HeapAlloc
HeapFree
Initialize library context, IsLegacy=%d
InitializeCriticalSection
InitializeCriticalSectionEx
InitializeSListHead
InternalName
Invalid legacy output buffer size specified: LIB_IOCTL_LEGACY_BUFFER_SIZE. error=%d
IOCTL buffers start with header meta data
IOCTL returned from kernel with error %d
IOCTL_DELETE_LW_MINIPORT_NIC
IOCTL_DELETE_MINIPORT_NIC
IOCTL_DIO_NIC_SET_ADDDRESSES
IOCTL_DIO_NIC_SET_MAC_ADDRESS
IOCTL_DISABLE_MINIPORT_NIC
IOCTL_ENABLE_MINIPORT_NIC
IOCTL_ENUM_NIC_COUNT
IOCTL_ENUM_NICS
IOCTL_ENUM_PORT_COUNT
IOCTL_ENUM_PORTS
IOCTL_ENUM_PROC_COUNT
IOCTL_ENUM_PROCS
IOCTL_ENUM_SWITCH_COUNT
IOCTL_ENUM_SWITCHES
IOCTL_ENUM_VMQ_GROUP_COUNT
IOCTL_ENUM_VMQ_GROUPS
IOCTL_EXEC_MON_CONFIG_GET
IOCTL_EXEC_MON_CONFIG_SET
IOCTL_EXEC_MON_HISTORY_GET
IOCTL_EXEC_MON_OPERATION_COUNT
IOCTL_EXEC_MON_PENDING_COUNT
IOCTL_EXEC_MON_PENDING_GET
IOCTL_EXEC_MON_RESET
IOCTL_INIT_LW_MINIPORT_NIC
IOCTL_INIT_MINIPORT_NIC
IOCTL_NIC_COLLECT_INT_STATS
IOCTL_NIC_CONNECT
IOCTL_NIC_DISABLE_OPTIMIZATIONS
IOCTL_NIC_DISCONNECT
IOCTL_NIC_ENABLE_OPTIMIZATIONS
IOCTL_NIC_GET_ADDRESSES
IOCTL_NIC_GET_DROP_REASONS_STATS
IOCTL_NIC_GET_INFO
IOCTL_NIC_GET_INT_STATS
IOCTL_NIC_GET_OPERATIONAL_STATUS
IOCTL_NIC_GET_STATS
IOCTL_NIC_GET_VLAN_INFO
IOCTL_NIC_GET_VMQ_INFO
IOCTL_NIC_GET_VRSS_INDIRECTION_ENTRIES_COUNT
IOCTL_NIC_GET_VRSS_INFO
IOCTL_NIC_MORPH_TO_DIONIC
IOCTL_NIC_MORPH_TO_VMNIC
IOCTL_NIC_RELEARN_MAC
IOCTL_NIC_SEND_STATUS
IOCTL_NIC_SET_CONNECTION_INFO
IOCTL_NIC_SET_INFO
IOCTL_NIC_SET_PACKET_FILTER
IOCTL_PORT_CREATE
IOCTL_PORT_DELETE
IOCTL_PORT_ENUM_LEARNED_MAC
IOCTL_PORT_ENUM_LEARNED_MAC_COUNT
IOCTL_PORT_FEATURE_STATUS_GET
IOCTL_PORT_GET_ENCAP_INFO
IOCTL_PORT_GET_INFO
IOCTL_PORT_GET_REQUIRED_EXTENSIONS
IOCTL_PORT_GET_STATS
IOCTL_PORT_GET_VLAN
IOCTL_PORT_LOOKUP_FROM_MAC
IOCTL_PORT_PROPERTY_ADD
IOCTL_PORT_PROPERTY_DELETE
IOCTL_PORT_PROPERTY_ENUM
IOCTL_PORT_PROPERTY_GET
IOCTL_PORT_PROPERTY_SET
IOCTL_PORT_SET_ENCAP_INFO
IOCTL_PORT_SET_INFO
IOCTL_PORT_SET_REQUIRED_EXTENSIONS
IOCTL_PORT_SET_VLAN
IOCTL_PROC_GET_STATS
IOCTL_PROFILER_CLEAR_PROCESSOR_STATS
IOCTL_PROFILER_GET_PROCESSOR_STATS
IOCTL_SWITCH_CREATE
IOCTL_SWITCH_DELETE
IOCTL_SWITCH_EXTENSION_ENUM
IOCTL_SWITCH_FEATURE_STATUS_GET
IOCTL_SWITCH_GET_INFO
IOCTL_SWITCH_GET_STATS
IOCTL_SWITCH_PROPERTY_ADD
IOCTL_SWITCH_PROPERTY_DELETE
IOCTL_SWITCH_PROPERTY_ENUM
IOCTL_SWITCH_PROPERTY_GET
IOCTL_SWITCH_PROPERTY_SET
IOCTL_SWITCH_SET_INFO
IOCTL_VM_NIC_ALLOCATE_VF
IOCTL_VM_NIC_FREE_VF
IOCTL_VM_NIC_PAUSE
IOCTL_VM_NIC_RESTORE
IOCTL_VM_NIC_RESUME
IOCTL_VM_NIC_SUSPEND
IOCTL_VM_NIC_VMPHU_ZERO_BEGIN
IOCTL_VM_NIC_VMPHU_ZERO_COMPLETE
IOCTL_VMSWITCH_CONFIGURE_PROCESSORS
IOCTL_VMSWITCH_DEREGISTER_PROTOCOL
IOCTL_VMSWITCH_DISABLE_OPTIMIZATIONS
IOCTL_VMSWITCH_ENABLE_OPTIMIZATIONS
IOCTL_VMSWITCH_GET_GLOBAL_VARIABLE
IOCTL_VMSWITCH_GET_INIT_STATE
IOCTL_VMSWITCH_GET_INTERNAL_STATS
IOCTL_VMSWITCH_GET_PORT_HANDLE_COUNT
IOCTL_VMSWITCH_SERVICING_END
IOCTL_VMSWITCH_SERVICING_START
IOCTL_VMSWITCH_SET_GLOBAL_VARIABLE
IOCTL_VMSWITCH_SHUTDOWN
IsDebuggerPresent
IsProcessorFeaturePresent
kernelbase.dll
L$ fD
L$ SUVWH
L$ SVWAVH
L$ SVWH
L$ USVWATAVAWH
L$ UVWATAUAVAWH
l$ VWAVH
l$(E3
L$@I+
L$`A;
L$`Li
L$0E3
L$0fD
L$HE3
L$PA+
L$PH;
L$XH3
L9{Hu
L9D$Xt
L9O@t
LeaveCriticalSection
LegalCopyright
LibIoctlAddArrayRecordElement: VariableBufferSize=%d
LibIoctlAddArrayRecordEx: RecordType=%d, RecordVersion=%d, FixedSize=%d
LibIoctlAddRecordEx: Invalid parameter. OperationContext=%p, RecordType=%d, Record=%p, error=%d
LibIoctlAddRecordEx: RecordType=%d, RecordVersion=%d, FixedSize=%d, VariableBufferSize=%d
LibIoctlDeviceIoControl: Fail to allocate initial output buffer of size %d, error=%d
LibIoctlDeviceIoControl: Invalid parameter: NULL OperationContext
LibIoctlDeviceIoControl: legacy output buffer size is specified as LIB_IOCTL_LEGACY_REQUESTED_SIZE, and user failed to call SetOutputBufferSizeIfLegacy() before calling this function. error=%d
LibIoctlGetArrayRecordElementEx: request for element index (%d) exceeding numElements(%d) for RecordType=%d, error=%d
LibIoctlGetArrayRecordInfoEx: Invalid parameter. OperationContext=%p, RecordType=%d, RecordVersion=%p, FixedSize=%p, NumElements=%p, error=%d
LibIoctlGetRecordEx: Found more than 1 element (%d) for the record RecordType=%d, error=%d
LibIoctlGetRecordEx: Invalid parameter. OperationContext=%p, RecordType=%d, RecordVersion=%p, FixedSize=%p, Record=%p, error=%d
LibIoctlGetRecordEx: RecordType=%d. Got record with info: RecordVersion=%d, FixedSize=%d, VariableBufferSize=%d, Record=%p
LibIoctlHelperAddArrayRecord: Fail to allocate memory for temp record for RecordType=%d, error=%d
LibIoctlHelperAddArrayRecordElement: Failed to allocate memory for array element, size=%d, RecordType=%d, error=%d
LibIoctlHelperAddArrayRecordElement: Failed to find in-progress array operation. error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer does not return actual value for buffer size. legacy fixedSize=%d, legacy variableBufferSize=%d. error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: element (%p) does not exist in record. error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: element index (%d)exceeds num elements specified in legacy database (%d). Element not added.
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. fixedSize=%d, variableBufferSize=%d, error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. fixedSize=LIB_IOCTL_LEGACY_BUFFER_SIZE, variableBufferSize=%d, error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. Record with LIB_IOCTL_LEGACY_BUFFER_SIZE is not last record. error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: legacy fixedSize (%d) is not same as record's size (%d)
LibIoctlHelperCalculateSizeInLegacyBuffer: legacy variableBufferSize (%d) is not same as element's size (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. fixedSize exceeds buffer size. OffsetFromStart=%d, fixedSize=%d, bufferSize=%d, error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. fixedSize(%d) > maxElementSize(%d), error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. Record with LIB_IOCTL_LEGACY_BUFFER_SIZE is not last record. error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. variableBufferSize exceeds buffer size. OffsetFromStart=%d, variableBufferSize=%d, bufferSize=%d, error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: legacy fixedSize (%d) is not same as record fixedSize (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: legacy numElements (%d) is not same as record info (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: legacy variableBufferSize (%d) is not same as element's variableBufferSize (%d)
LibIoctlHelperCopyRecordToVersionedBuffer: Failed to copy data to buffer (buffer too small). BufferSize=%d
LibIoctlHelperInitialize: Invalid dispatch functions: DispatchTable=%p, MemAlloc=%p, MemFree=%p
LibIoctlHelperInitializeOperation: Fail to allocate memory for operation context (size=%d). error=%d
LibIoctlHelperInitializeOperation: IsLegacy specified, but DispatchTable->GetLegacyInfo is NULL. error=%d
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: error in legacy database. RecordType=%d, record offset (%d) exceeds bufferSize (%d). error=%d
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: invalid legacy info for RecordType=%d. FixedSize=%d, VariableBufferSize=%d, NumElements=%d, error=%d
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: RecordType=%d not found in legacy database
LibIoctlHelperPrivGetRecordSize: Invalid record header format. HeaderSize=%d, VariableBufferSizeArrayOffset=%d, NumElements=%d
LibIoctlHelperPrivGetVersionedArrayRecordInfo: Buffer contains record of size 0
LibIoctlHelperPrivGetVersionedArrayRecordInfo: RecordType=%d not found in buffer
LibIoctlHelperPrivValidateLegacyBufferInfo: Index=%d. Legacy info contains 0 element
LibIoctlHelperPrivValidateLegacyBufferInfo: overflow fixedSize=%d, variableBufferSize=%d
LibIoctlInitializeOperation: Called with legacy IOCTL code 0x%x error=%d
LibIoctlInitializeOperation: IOCTL library either failed, or has not been initialized.
LibIoctlInitializeOperation: OperationContext is NULL
LibIoctlInitializeOperation: Unable to find legacy IOCTL code for %x to communicate with legacy driver. error=%d
LibIoctlInitializeOperation: Use legacy IOCTL (0x%x) instead of IOCTL (0x%x)
LibIoctlPrivAllocateLegacyInputBuffer size=%d
LibIoctlPrivAllocateLegacyInputBuffer: legacy input buffer size is specified as LIB_IOCTL_LEGACY_REQUESTED_SIZE, and user failed to call SetInputBufferSizeIfLegacy() before calling LibIoctlDeviceIoControl. error=%d
LibIoctlPrivAllocateLegacyInputBuffer: Using user-requested size for input buffer: %d
LibIoctlPrivAllocateVersionedInputBuffer, size=%d
LibIoctlPrivConstructInputBuffer - input bufer was already constructed
LibIoctlPrivConstructInputBuffer - input buffer constructed
LibIoctlPrivSendIoctl
LibIoctlPrivSendIoctl: Failed to allocate IOCTL output buffer with size %d
LibIoctlPrivSendIoctl: First IOCTL returns output buffersize needed=%d
LibIoctlPrivSendIoctl: IOCTL returns with error=%d
LibIoctlPrivSendIoctl: Second IOCTL returns with error=%d
LibIoctlPrivSetInitialOutputBuffer with size=%d
LibIoctlSetOutputBufferSizeIfLegacy: OutputBufferSize=%d
LibIoctlValidateLegacyInfo: Invalid legacy database inputBuffer size != 0 or LIB_IOCTL_LEGACY_REQUESTED_SIZE for IOCTL 0x%x
LibIoctlValidateLegacyInfo: Invalid legacy database LegacyIoct(0x%x) = NewIoctl(0x%x)
LibIoctlValidateLegacyInfo: Invalid legacy input info for IOCTL 0x%x, FixedSize=%d, VariableBufferSize=%d, NumElements=%d
LibIoctlValidateLegacyInfo: Invalid legacy output buffersize (LIB_IOCTL_LEGACY_BUFFER_SIZE)
LibIoctlValidateLegacyInfo: Invalid legacy output info for IOCTL 0x%x, FixedSize=%d, VariableBufferSize=%d, NumElements=%d
LibIoctlValidateLegacyInfo: validation for index %d failed for input info for IOCTL 0x%x
LibIoctlValidateLegacyInfo: validation for index %d failed for output info for IOCTL 0x%x
lntdll.dll
Local\SM0:%lu:%lu:%hs
LogHr
LogNt
M H1E
M@L9uP
Marks NBL as fully shadowed using bits in FORWARDING_EXTENSION
MaskAddress
memcmp
memcpy
memmove
memset
Microsoft
Microsoft Corporation
Microsoft.Windows.Hyper.V.VmsIf
mRich
Msg:[%ws] 
ntdll.dll
ntelA
NtQueryWnfStateData
NtUpdateWnfStateData
oHD9m
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
onecore\internal\sdk\inc\wil\Staging.h
OpenSemaphoreW
OriginalFilename
OutputDebugStringW
p:_0#
pA_A^_^]
pA_A^A]A\_^]
PA_A^A]A\_^]
pA_A^A]A\_^]
ProductName
ProductVersion
q:_0#
q@W>,
q0R^G'
qh\t.
QueryPerformanceCounter
RaiseFailFastException
RecordType=%d, RecordVersion=%d, FixedSize=%d
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
ReservedFeature
ReturnHr
ReturnNt
Returns VLAN information
rJfD9?w
RSDS:
RtlCaptureContext
RtlCompareMemory
RtlDisownModuleHeapAllocation
RtlDllShutdownInProgress
RtlLookupFunctionEntry
RtlNotifyFeatureUsage
RtlNtStatusToDosErrorNoTeb
RtlRegisterFeatureConfigurationChangeNotification
RtlUnregisterFeatureConfigurationChangeNotification
RtlVirtualUnwind
s WAVAWH
SetLastError
SetThreadpoolTimer
SetUnhandledExceptionFilter
SLB_DECAP_LAYER
SLB_NAT_LAYER
StringFileInfo
Successfully query vmswitch capabilities. Initializing VMSIF with those capabilities.
Supports configurable parameters to modify switch performance
Supports device-less host MINIPORTs
Supports disabling vmbus monitored notifications to vmNIC
Supports Enablement/Disablement of By passing extension stack and setting Required Extensions
Supports hardware timestamping of NBLs
Supports IOCTL to query capabilities
Supports non-consecutive CPUs in RSS/VMMQ OIDs.
Supports proxy driver for host vNICs
Supports reload-sensitive IOCTLs.
Supports RSC Enablement/Disablement per vPort
Supports setting of VMBUS affinity policy
Supports state separation
Supports vmswitch Phu-Zero reloadability
Supports vmswitch reloadability
SUVWATAUAVAWH
SVWAVH
SWITCH
t ;;wz
t"@8=N
t$ UWAVH
t$ WATAUAVAWH
t$ WH
T$8L+
T$dfD
t$hD;
t$P!|$HH!|$@D
t$PE3
t$PH+
T$PL;
t(D8-}
t(D8=
t,D8=
t.;/w
t:fA9(t4H
t;L9J
t[D9m
t_D9e
t1B9\
t4E88t/H
t5L9J
t9H9A
taD9m
TerminateProcess
The vSwitch has support for hot patch IOCTL
Translation
tV;.v
tx@8=
tYD9e
u#H!X
u%I!C
u{H9A
u1+|$`H
u8!{LH!{@A
UAVAWH
Underflow VmsIfOutstanding handle count!
UnhandledExceptionFilter
UNKNOWN
Unknown exception
USVWATAUAVAWH
UVWATAUAVAWH
UVWAVAWH
UWATAVAWH
v!D$HH
VarFileInfo
VfcAddObject
VfcAddObjectSet
VfcBlockLayerCreation
VfcBlockPort
VfcBlockPortOnRestore
VfcCleanNatRangeFlows
VfcClearLayerActivePings
VfcDeleteLayerMetadataKey
VfcDepositNatRange
VfcDePreserveVlan
VfcDeregisterEvent
VfcDeregisterEventEx
VfcDeserializeObjectsGlobal
VfcDeserializeObjectsOnPort
VfcDeserializeObjectsOnSwitch
VfcDisablePingResponder
VfcDisablePort
VfcEnablePingResponder
VfcEnablePort
VfcForceAddObjectSet
VfcGetInformation
VfcGetLayerMetadataValue
VfcInitializeDescriptor
VfcInjectPacket
VfcInjectPacketEx
VfcInterceptEvent
VfcInterceptEventEx
VfcInterceptEventEx2
VfcInterceptEventEx3
VfcListLayerActivePings
VfcListLayerMetadataKeys
VfcListLayerMetadataValues
VfcListObject
VfcMappingEvent
VfcMatchTupleAtLayer
VfcMonitoringPing
VfcNatEvent
VfcNatEventAsync
VfcOpenDevice
VfcPersistHostState
VfcPrepareForUninstall
VfcPreserveVlan
VfcProcessTuples
VfcReleaseList
VfcRemoveAllObject
VfcRemoveMapping
VfcRemoveMappingEx
VfcRemoveNatRange
VfcRemoveObject
VfcReplaceGroupAndRules
VfcReplaceLayerFlowTableAddress
VfcReplaceObjectSet
VfcSampleFlowState
VfcSerializeObjectsGlobal
VfcSerializeObjectsOnPort
VfcSerializeObjectsOnSwitch
VfcSetDirectInterfaceMode
VfcSetGlobalGftMultiTenancy
VfcSetGroupCondition
VfcSetGroupOption
VfcSetHeuristicTimerUpdates
VfcSetInformation
VfcSetLayerMetadataValue
VfcSetPktMonState
VfcSetPortTraceFilters
VfcSetTraceFilteringState
VfcUnblockLayerCreation
VfcUnblockPort
VfcUnblockPortOnRestore
VfcWithdrawNatRange
vfpapi.dll
vfpapi.pdb
VM Filtering Platform User Mode API Library
VmsCapabilityFeatureConfigureGlobalsUsingIoctl
VmsCapabilityFeatureConfigureSwitchExtensionParameters
VmsCapabilityFeatureConfigureSwitchPerfParameters
VmsCapabilityFeatureDisableVmNicIM
VmsCapabilityFeatureDynamicVMMQ
VmsCapabilityFeatureExtensibilityStackBypass
VmsCapabilityFeatureHardwarePacketTimestamp
VmsCapabilityFeatureHostNicUseL2IndirectionTable
VmsCapabilityFeatureHostVNicProxy
VmsCapabilityFeatureHotPatchIOCTL
VmsCapabilityFeatureIndependentHostSpreading
VmsCapabilityFeatureLightweightMiniports
VmsCapabilityFeatureNblOobIndicateUncachedData
VmsCapabilityFeatureNonConsecutiveRssCpus
VmsCapabilityFeatureNrtNameResolutionId
VmsCapabilityFeaturePacketMonitor
VmsCapabilityFeaturePacketTracking
VmsCapabilityFeatureQueryCapabilitiesIoctl
VmsCapabilityFeatureQueryVlanInfo
VmsCapabilityFeatureReloadability
VmsCapabilityFeatureReloadSensitiveIoctls
VmsCapabilityFeatureReserved
VmsCapabilityFeatureRscOnVPortLevel
VmsCapabilityFeatureSoftwareRscOnPhysicalNic
VmsCapabilityFeatureStateSeparation
VmsCapabilityFeatureSuspendedLiveMigration
VmsCapabilityFeatureUntrustedGuestIsolation
VmsCapabilityFeatureVersionedIoctl
VmsCapabilityFeatureVmbusAffinityPolicy
VmsCapabilityFeatureVmPhuZeroReloadability
VmsEnumeratePort
VmsSendDeviceIoControl
VmsSendFilterIoControlEx
VS_VERSION_INFO
VWAVH
WaitForSingleObject
WaitForSingleObjectEx
WaitForThreadpoolTimerCallbacks
WATAUAVAWH
WAVAWH
WilError_03
WilStaging_02
x ATAVAWH
x AUAVAW
x AVH
xA_A^A]A\_^[]
xA_A^A]A\_^][
