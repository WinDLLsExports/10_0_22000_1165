 A^_^
 A^A\_
 A_A^_
 A_A^_^]
 A_A^A\
 A_A^A]A\_
 A_A^A]A\_^]
 H3E H3E
 http://www.microsoft.com/windows0
 Microsoft Corporation. All rights reserved.
 Microsoft Operations Puerto Rico1
 Microsoft Operations Puerto Rico1&0$
 Operating System
 Windows
!(wil::verify_bool(CopyFileW(srcPath.GetChars(), destPath.GetChars(), 0)))
!(wil::verify_bool(hKeepRunningThread))
!(wil::verify_bool(QueryServiceStatus(service.get(), &serviceStatus)))
!(wil::verify_bool(versionSize > 0))
!]_0t
!0H!t$pI
!This program cannot be run in DOS mode.
!TkjE
"Microsoft Window
"system" applyFilter="Yes">
"user">
%|fUN<
%CSIDL_LOCAL_APPDATA%\Microsoft\Windows\Notifications
%CSIDL_LOCAL_APPDATA%\Packages\$\SystemAppData
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%u)\%hs!%p: 
%Microsoft Windows Production PCA 2011
%Microsoft Windows Production PCA 20110
%ProgramData%\Microsoft\Windows\AppRepository
%ProgramData%\Microsoft\Windows\AppRepository\CheckPoint.VPN_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\f5.vpn.client_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\FileManager_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\JuniperNetworks.JunosPulseVpn_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\Microsoft.MoCamera_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\SonicWALL.MobileConnect_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\windows.immersivecontrolpanel_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\winstore_*_cw5n1h2txyewy.xml
%PROGRAMDATA%\Microsoft\Windows\AppxProvisioning.xml
%ProgramFiles%\WindowsApps\
%s file does not exist
%s file exists
%s for user %s is known to CapAuth
%s for user %s isn't known to CapAuth (needs Registration)
%s key not found, skipping GatherDataForProcessAllUserStorePackages
%s service status = 0x%x
%s\%s
%s\%s%s
%s_%s_%s_%s
%SystemRoot%\System32\
%WINDIR%\System32\AppxProvisioning.xml
%ws not found yet, filling entry
%ws: %ws
&S|9a
(A^_^[
(caller: %p) 
(Default)
(lastError != ERROR_FILE_NOT_FOUND)
)Microsoft Root Certificate Authority 20100
)onecore\base\appmodel\runtime\src\systemmetadatainternal.cpp
*cursor == L'\0'
*isPackageEndOfLife
,45rTznX0lCJdFgP1NgKPJscHxGueerKGk4X4KXxqhMU=0Z
,D9>t
... Package %ws is all-user installed so no need to write its upgrade key
... Package %ws is being end of lifed so it's being written to the EndOfLife key
... Package %ws is dev mode. Writing to upgrade keys
... Package %ws is LOB so no need to write its upgrade key
... Package %ws is NOT being end of lifed so it's being written to the Downlevel Installed key
... Package %ws is not installed. Nothing to do
... Package %ws is OEM so no need to write its upgrade key
... Package's root is %ws
... Unable to process recovery info for package 0x%x. Assume this app is fully on system volume
.?AVexception@@
.?AVResultException@wil@@
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.data
.data$brc
.data$r$brc
.edata
.gehcont
.gfids
.giats
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.L9u8t7L
.pdata
.rdata
.rdata$brc
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.recovery
.rsrc$01
.rsrc$02
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.xdata
.xdata$x
.xn--
/OfflineSoftwareHive:"
:%|fUu=
;d:|v
;EPwFA
??0exception@@QEAA@AEBV0@@Z
??0exception@@QEAA@XZ
??1exception@@UEAA@XZ
??1type_info@@UEAA@XZ
?terminate@@YAXXZ
@.data
@.reloc
@.rsrc
@8|$@t
@8|$B
@8y(t
@A^_]
@A^_^
@A^_^[]
@A^A\_
@A_A^_
@A_A^_^]
@A_A^A\_^
@A_A^A]A\_
@A_A^A]A\_^]
@FamilyName
@FullName
@IsLOBApp
@PackageType
@ProvisionSourceIsBundle
@SUVWATAUAVAWH
@SUVWATAVAWH
@SUVWAVAWH
@USVWATAUAVAWH
@USVWATAUAVH
@USVWATAUAWH
@USVWATAVAWH
@USVWAUAVAWH
@USVWAUAVH
@USVWAVAWH
@USVWAVH
@USVWH
@USWH
@UVWATAUAVAWH
@UVWAVAWH
@UVWH
@UWATAVAWH
@UWAVH
@VWATAVAWH
@VWAVH
[%hs(%hs)]
[%hs]
[Desktop Only] Failed to find cellular modem in the descover phase.
[Desktop Only]Package family %ws is end-of-lifed
\$ E3
\$ H+
\$ UH
\$ UVW
\$ UVWAVAWH
\$ UVWH
\* [*]</pattern>
\*.xml
\\?\UNC\
\Applications\
\AppxManifest.xml
\AppxMetadata\AppxBundleManifest.xml
\Autogen
\Frameworks\
\InfusedApps
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
\microsoft.system.package.metadata
\OSRollbackPackages.txt
\Packages\
\PluginExecutedFixStateRepository
\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts
\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths
\zV&8
]</pattern>
]HD8}8
]HfA;
_&b!K
__C_specific_handler
__CxxFrameHandler3
__dllonexit
_amsg_exit
_Classes
_CxxThrowException
_initterm
_lock
_onexit
_purecall
_unlock
_vsnprintf_s
_vsnwprintf
_wcsicmp
_wcsnicmp
_XcptFilter
` UAVAWH
`.rdata
`0^0\
`A^_^[]
`A_A^]
`A_A^_^]
`A_A^A\^]
`A_A^A]A\_^]
{OX,*
|$ AVH
|$0E3
|$A@8
|$DE3
|$hA;
|$PE3
|$XE3
}0H+}(H
}bwu=
}gfD9}o
}HD8}8
}HfD9}8A
</objectSet></exclude>
</objectSet></include>
</objectSet></locationModify>
</objectSet></merge>
</objectSet></unconditionalExclude>
</rules></migXml>
<?xml version="1.0" encoding="utf-8"?><xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:element name="AppxProvisionList">  <xs:complexType>    <xs:all>      <xs:element name="EndOfLife" type="CT_EndOfLife" minOccurs="0"/>      <xs:element name="Provisioned" type="CT_Provisioned" minOccurs="0"/>    </xs:all>  </xs:complexType>  <xs:unique name="Package_FamilyName">    <xs:selector xpath="m:EndOfLife/m:Package"/>    <xs:field xpath="@FamilyName"/>  </xs:unique>  <xs:unique name="Package_FullName">    <xs:selector xpath="m:Provisioned/m:Package"/>    <xs:field xpath="@FullName"/>  </xs:unique></xs:element><xs:complexType name="CT_EndOfLife">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FamilyName" type="ST_FamilyName" use="required"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:complexType name="CT_Provisioned">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FullName" type="ST_FullName" use="required"/>        <xs:attribute name="PackageType" type="ST_PackageType"/>        <xs:attribute name="ProvisionSourceIsBundle" type="xs:boolean"/>        <xs:attribute name="IsLOBApp" type="xs:boolean"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:simpleType name="ST_FamilyName">  <xs:restriction base="xs:string">    <xs:minLength value="17"/>    <xs:maxLength value="64"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_FullName">  <xs:restriction base="xs:string">    <xs:minLength value="30"/>    <xs:maxLength value="127"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_PackageType">  <xs:restriction base="xs:string">    <xs:enumeration value="resource"/>    <xs:enumeration value="framework"/>    <xs:enumeration value="bundle"/>  </xs:restriction></xs:simpleType></xs:schema>
<@/t5L
<@\t=fB
<exclude><objectSet>
<include><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%ProgramFiles%\WindowsApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime&apos;)"><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%windir%\InfusedApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime\InfusedApps&apos;)"><objectSet>
<merge script="MigXmlHelper.DestinationPriority()"><objectSet>
<merge script="MigXmlHelper.SourcePriority()"><objectSet>
<migXml xmlns=""><rules context=
<P/u(
<pattern type="File">
<pattern type="Registry">
<String too big>
<unconditionalExclude><objectSet>
>ARI8u!A
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>NGdx
040904B0
0A^_]
0A^_^
0A^A\_
0A_A^_
0A_A^_^]
0A_A^A\_^
0A_A^A]A\_
0A_A^A]A\_^]
0x%x: Could not get path to provisioning XML -- not performing EOL and provisioned-package cleanup
1(0&0
1,0*0
10.0.22000.1165
10.0.22000.1165 (WinBuild.160101.0800)
111019184142Z
1234567890abcdefghjkmnpqrstvwxyzABCDEFGHJKMNPQRSTVWXYZ
20221013202820Z
20221014020741.997Z0
20221014202820Z0t0:
210930182225Z
220302185142Z
220505192314Z
229879+4700210
230504192314Z0p1
230511185142Z0
261019185142Z0
300930183225Z0|1
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
5fD9n
8\$@A
8]\.t
8A^_^[
8twt0P
9(v H
97t:A
98v H
9A98uCA9x
9N4t\A
9N4tN
9O4t?A
9O4t>
9O4tN
a tSH
A,9A(
A^_^[]
A^A]]
A^A]_^[]
A^A]A\_^[]
A_A]A\_]
A_A]A\_^[]
A_A^]
A_A^_
A_A^_^[]
A_A^_^]
A_A^A\
A_A^A\^]
A_A^A\_]
A_A^A\_^[]
A_A^A\_^][
A_A^A]_]
A_A^A]_^[]
A_A^A]A\]
A_A^A]A\_
A_A^A]A\_[]
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
a_m|i
A8_0t
A8_1u
A8_2u
A8_8t
A8}0t
A9~0u
A9u0t)H!|$pH
About to call ResetPluginTimer.
AcquireSRWLockExclusive
AcquireSRWLockShared
AddPackageRegistryKeyToArray(fullName, &bundleFullNames)
AddPackageRegistryKeyToArray(fullName, &packageFullNames)
AddUplevelPackageToDelete(subKey, keysToDelete)
ADVAPI32.dll
allUserApplicationsKey.CopyTree(packageToWrite, mainPackageKey)
allUserApplicationsKey.DeleteSubKeyTree(keysToDelete[i]->GetChars())
allUserApplicationsKey.OpenIfExists(HKEY_LOCAL_MACHINE, allUserStoreApplicationsPath.GetChars(), KEY_READ)
allUserApplicationsKey.OpenSubKey(allUserPackageFullName, KEY_READ, &downlevelAllUserPackageKey)
allUserApplicationsKey.OpenSubKey(subKey, KEY_READ, &mainPackageKey)
allUserApplicationsKey.SetUInt32Value(regIuiPolicyCheckedString, 1)
allUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &deprovisionedKey)
allUserStoreKey.GetKeySecurity(DACL_SECURITY_INFORMATION, allUserStoreSD)
allUserStoreKey.Open( HKEY_LOCAL_MACHINE, effectiveAllUserStorePath, KEY_READ | KEY_WRITE | WRITE_DAC)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, allUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, offlineAllUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.OpenSubKey( s_Applications, KEY_READ | KEY_WRITE | WRITE_DAC, &allUserApplicationsKey)
allUserStoreKey.OpenSubKey( s_EndOfLife, KEY_READ | KEY_WRITE | WRITE_DAC, &endOfLifeKey)
allUserStoreKey.OpenSubKey( s_Staged, KEY_READ | KEY_WRITE | WRITE_DAC, &stagedKey)
allUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &allUserStagedKey)
allUserStoreKey.OpenSubKey(userSid, KEY_READ, &userKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::allUserApplicationsString, KEY_READ, &allUserApplicationsKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::inboxApplicationsString, KEY_READ, &inboxApplicationsKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::stagedApplicationsString, KEY_READ, &stagedKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::upgradeApplicationsString, KEY_READ, &upgradeKey)
allUserStoreKey->OpenSubKey(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
api-ms-win-appmodel-runtime-l1-1-1.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-heap-obsolete-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-libraryloader-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-version-l1-1-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-security-provider-l1-1-0.dll
api-ms-win-security-sddl-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
AppDataVolumeKey
AppDataVolumeName
AppDB
appdb.dat
AppendPackagePathAndApplyTrustLabel(offlinePackagePath.GetChars(), applicationPath, offlineSoftwareHive, cmdLineBuilder)
APPID
Applications
applicationsKey.GetUInt32Value(appxUpgradeNeededValueName, &appxUpgradeNeededValue)
applicationsKey.GetUInt32Value(noReRegisterOnUpgradeValueName, &noReRegisterOnUpgradeValue)
applicationsKey.GetUInt64Value(downlevelOSVersionValueName, &this->downlevelOSVersion)
applicationsKey.SetUInt32Value(appxUpgradeNeededValueName, this->appxUpgradeNeeded ? 1 : 0)
applicationsKey.SetUInt32Value(noReRegisterOnUpgradeValueName, this->noReRegisterOnUpgrade ? 1 : 0)
applicationsKey.SetUInt64Value(downlevelOSVersionValueName, this->downlevelOSVersion)
applicationsPathBuilder.AppendString(Common::Deployment::applicationsDir)
applicationsPathBuilder.AppendString(infusedAppsFolder.GetChars())
Applying downlevel stub preference %d for package %ws
ApplySuccessFailed
ApplyTrustLabel(cmdLineBuilder.GetChars())
ApplyTrustLabelToPackages failed 0x%x
ApplyTrustLabelToPackagesUnderRegistryKey(&packageFamilyKey, applicationPath, offlineSoftwareHive, cmdLineBuilder)
ApplyTrustOffline.exe
AppModelPackageRepository
AppModelRoot
AppReadiness
AppsEOL
Appx Migration Plugin called RtlGetDeviceFamilyInfoEnum: downlevelOSVersion=0x%llx
Appx Migration Plugin called SRCheckIntegrity(%s): Entrypoint not found (0x%x)
Appx Migration Plugin called SRCheckIntegrity(%s): Module (%s) not present
Appx Migration Plugin called SRCheckIntegrity(%s): Module not loaded (0x%x)
Appx Migration Plugin version number is %d.%d.%d.%d
Appx Migration Plugin will not perform re-registration of Packages (OSupgradeInPlace)
Appx Migration Plugin will perform re-registration of Packages (OSswap)
Appx Upgrade Migration Plugin
AppX*
AppxAllUserStore
AppxAllUserStore::GetAllUserApplicationsFullPath(&allUserStoreApplicationsPath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePathBuffer)
AppxAllUserStore::GetEndOfLifeApplicationsFullPath(&endOfLifePath)
AppxAllUserStore::GetInboxApplicationsFullPath(&inboxPackagesBuffer)
AppxAllUserStore::GetStagedApplicationsFullPath(&allUserStoreStagedPath)
AppxAllUserStore::GetUpgradeApplicationsFullPath(&upgradePath)
AppxAllUserStore::SetPackageOverrideSetupPhaseHelper(packageFamilyName.GetChars(), AppxAllUserStore::c_setupPhase_PostShell)
AppxCleanupOrphanPackages
AppxCleanupOrphanPackages()
AppxCleanupSystemAppsMigratedToFOD
AppxCleanupSystemAppsMigratedToFOD()
AppxDeploymentClient.dll
AppxDestagePackage
appxFactory->CreateBundleManifestReader(manifestStream.Get(), bundleManifestReader.GetAddressOf())
AppxManifest.xml
AppxMetadata\AppxBundleManifest.xml
AppxPackageVolumes
AppxPreRegisterAllInboxPackages
AppxPreRegisterAllInboxPackages failed: 0x%x
AppxPreRegisterPackage
AppxProvisioning.xml not found in programdata folder, trying system32 location
AppxProvisionList
AppxRoot
AppxStateChange
AppxSvc
AppxUpgradeMigration discontinuing plug-in timeout extension.
AppxUpgradeMigration executing longer than expected.
AppXUpgradeMigration exiting.
AppXUpgradeMigration signaling extension thread.
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL %lu
AppxUpgradeMigration::AppxUpgradeMigration: failed reading EOL reg vaue
AppxUpgradeMigration::AppxUpgradeMigration: Failed to write cellular already EOL reg key value
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: CLSIDFromString error = %8.8X
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Enter
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Exit
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed DevObjOpenDevRegKey error = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed NetCfgInstanceId error = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Failed to write cellular reg key value
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Failed to write cellular reg key value in the uplevel OS
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: found only one interface, skipping check
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Found wireless WAN
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: foundCellularModem = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: has modem = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: index = %lu
AppxUpgradeMigration::Discover called
AppxUpgradeMigration::Discover done (0x%x)
AppxUpgradeMigration::FoundCellularModemInstalled: failed to find a modem from the 'gather' phase
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from a prior run = %lu.
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from the 'gather' phase
AppxUpgradeMigration::FoundCellularModemInstalled: value doesn't exist
AppxUpgradeMigration::Gather called
AppxUpgradeMigration::IsWirelessWanInterfaceType ConvertInterfaceGuidToLuid error = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType GetIfEntry2 error = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.MediaType = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.PhysicalMediumType = %lu
AppxUpgradeMigration:EOL-Messaging/MobilePlans
AppxUpgradeMigrationPlugin.dll
APPXUPGRADEMIGRATIONPLUGIN.dll
AppxUpgradeMigrationPlugin.dll
AppxUpgradeMigrationPlugin.pdb
AppxUpgradeNeeded
arm64
as.,k{n?,
ATAVAWH
ATL$__a
ATL$__m
ATL$__z
AutoCheckIntegrity
Autogen
autogenDirectoryPath.SetValueFromString(this->singleInstanceStore.GetChars())
backupManifestPathBuilder.AppendString(backupManifestDir.GetString())
backupManifestPathBuilder.AppendString(L".xml")
backupManifestPathBuilder.AppendString(L"\\")
backupManifestPathBuilder.AppendString(package)
BiZ8S1
bstrOnlineFilePath.CopyFromString(onlineFilePath)
bstrOnlineRegistryPath.CopyFromString(onlineRegistryPathBuffer.GetChars())
bstrPath.CopyFromString(path.GetChars())
bstrSisPath.CopyFromString(sisPath)
bundle
Bundle
Bundle %ws is being written to the downlevel installed key
bundleAndMainPackage->bundle.SetValueFromString(packageFullName)
bundleAndMainPackage->mainPackage.SetValueFromString(packageFullName)
BundleFullName
bundleInfoRootKey.CreateSubKey(bundleFullName, KEY_READ | KEY_WRITE, &bundleKey)
bundleInfoRootKey.OpenSubKey(bundleFullName, KEY_READ, &bundleKey)
bundleKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
bundleKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
BundleManifestInfo
bundleManifestReader->GetPackageInfoItems(&packages)
bundlesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
BX9A4t
C @8}Wu
C9fD9?u1
callContext
CallContext:[%hs] 
Calling ApplyTrustLabel
Calling DeleteOSRollbackPackagesRegistry
Calling SavePackageListFromFileToRegistry
CallRtlGetDeviceFamilyInfoEnumIfFunctionAvailable(nullptr, &deviceFamily, nullptr)
Cannot find package %ws in SIS, not writing to Staged Key
CellularAppsRemoved
cfD9}o
CheckOrFixStateRepositoryViaExport called to %s
CheckOrFixStateRepositoryViaExport done %s. Disposition: %d
CheckRepository(Fix) reports Disposition=%d, #ErrorsCorrected=%I64u
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
Cleaning up orphan packages from downlevel OS
Cleaning up SystemApps migrated to FOD
CloseHandle
CloseServiceHandle
CloseThreadpoolTimer
CLSIDFromString
cmdLine.get() != nullptr
cmdLineBuilder.AppendChar(L' ')
cmdLineBuilder.AppendChar(L'\"')
cmdLineBuilder.AppendString(applicationPath)
cmdLineBuilder.AppendString(offlineSoftwareHive)
cmdLineBuilder.AppendString(offlineSoftwareHiveParam)
cmdLineBuilder.AppendString(packagePath)
cmdLineBuilder.SetLength(0)
CoCreateInstance
CoCreateInstance( __uuidof(AppxBundleFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IAppxBundleFactory), &appxFactory)
CoCreateInstance( __uuidof(OpcFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IOpcFactory), &opcFactory)
CoGetApartmentType
CoGetInterfaceAndReleaseStream
CoInitializeEx
com1.
com2.
com3.
com4.
com5.
com6.
com7.
com8.
com9.
CoMarshalInterThreadInterfaceInStream
CoMarshalInterThreadInterfaceInStream(IID_IMigrationContext, this->context, &pStream)
Common::Deployment::Configuration::GetPackageRepositoryRoot(&this->packageRepository)
Common::Deployment::GetPackageIDFromPackageMoniker( existingFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( packageFullName, nullptr, &currentPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( provisionedInstalledPackageFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( uplevelProvisionedPackage, nullptr, &provisionedPackageID)
Common::Deployment::GetVersionlessNameFromPackageFullName( fullName, &versionlessName)
Common::Deployment::GetVersionlessNameFromPackageFullName( packageFullName, &versionlessName)
Common::Deployment::GetVersionlessNameFromPackageFullName(packageFullName, &versionlessName)
Common::Deployment::ManifestCache::UpdateOptions(Common::Deployment::ManifestCache::Options_ReloadAllInbox)
Common::Deployment::SaveWindowsAppsPackageListToFile(filename.GetChars())
Common::DirectoryExists(autogenDirectoryPath.GetChars(), &folderExists)
Common::DirectoryExists(folderPath, &folderExists)
Common::DirectoryExists(metadataFolder.GetChars(), &metadataExistsInPackageRoot)
Common::DirectoryExists(metadataFolderInSharedLimitedTime.GetChars(), &packageExistsInSharedLimitedTime)
Common::DirectoryExists(systemMetadataDirectoryForPackage, &systemMetadataForPackageExists)
Common::FileExists(applyTrustLabelAppFullPath.GetChars(), &fileExists)
Common::FileExists(fileName.GetChars(), &fileExists)
Common::FileExists(recoveryFileFullPath.GetChars(), &recoveryFileExists)
Common::FileExists(sourceBackupManifestFilePathBuilder.GetChars(), &sourceFileExists)
Common::FileExists(targetBackupManifestFilePath.GetChars(), &targetFileExists)
Common::StateSeparation::GetPackageRepositoryPackagesPath(nullptr, &packageRepositoryPackagesKeyPath)
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppModelRoot, &s_StubPreference, 1, &stubPreferenceKeyPath)
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppxStateChange, subkeys, ARRAYSIZE(subkeys), &fullPath)
Common::String::CaseInsensitiveStartsWith(subKey, L"S-", &isUserSid)
CompanyName
CompareStringOrdinal
Completed AppxPreRegisterAllInboxPackages
Completed EnsureAppRootPermissions - processed %i of %i directories.
Completed EnsureRegistryKeyPermissions
Completed EnumAndAddPackagesNotKnownToCapAuth
Completed FixStateRepositoryIntegrity -- was already run so no action needed.
Completed FixStateRepositoryIntegrity successfully.
Completed RepairBadPathsInHKU
Completed RepairPackageRepositoryKeyInHKLM
Completed RepairPackageRootFolderPathInRepositoryRegistryKey
Completed RepairPathValueInUserRegistryKey
Completed RepairStateRepository successfully.
context->ExpandEnvironmentVariables(pathBstr, &expandedPath)
context->get_WorkingDir(&workingDir)
context->GetOfflineFileLocation(expandedPath, &offlinePath)
context->GetOfflineStatus(&offlineExecution)
ConvertInterfaceGuidToLuid
ConvertStringSidToSid(packageContentsCapabilitySid, &packageContentsSid)
ConvertStringSidToSidW
CopyFile(sourceBackupManifestFilePath.GetChars(), targetBackupManifestFilePath.GetChars(), FALSE)
CopyFileW
CopyRegistryKeyWithoutAcls(allUserStoreKey, pluginAllUserStoreKey)
CopyRegistryKeyWithoutAcls(packageStateKey, stateChangeKey)
CopyRegistryKeyWithoutAcls(sourceSubKey, destinationSubKey)
CopyRegistryKeyWithoutAcls(stubPreferenceKey, stubPreferenceKeyCopy)
CoTaskMemAlloc
CoTaskMemFree
Could not open %ws: 0x%x -- not performing EOL and provisioned-package cleanup
CoUninitialize
CreateAppxProvisionFactory(&appxProvisionFactory)
created
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeKeyString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeNameString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeKeyString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeNameString, value.GetChars())
CreateEventW
CreateFileW
CreateMutexExW
CreateProcessW
CreateSemaphoreExW
CreateThread
CreateThreadpoolTimer
CreateTopLevelKeys(offlineExecution)
currentContextId
currentContextMessage
currentContextName
currentPackage->packageFullName.SetValueFromString(packageFullName)
D$ E3
D$(D8eXt
D$(E3
D$,D8-
D$@E3
D$`E3
D$`fD98t
D$`H9|$Xu
D$0H+
D$DA;
D$HE3
D$hfE
D$P t*L
d$pA!4$I
D$pE3
D$PH!\$(3
D$PH9\$Hu
D$pI9_
D$PL+
D$x;(r
D$x;8r
D$X9G4
D$xE3
D$XL9d$Pu
D;}(r
D+D$x
D+D$xD
D8|$@u)L
D8|$@uUL
D8|$0t9I
D8|$XA
D8d$0u;L
D8l$0t)L
D8l$0u[M
D8l$1
D8m@u
D8M8A
D8mwtnL
D8-ow
D8t$@t5L
D9(u]H
D9|$@
D9|$D
D9|$Du
D9d$(
D9d$(|
D9D$|
D9l$(|
DeleteCriticalSection
Deleted\
DeleteFileW
Deleting Uplevel all-user key %ws because downlevel had a more preferred version
Deprovisioned
DeprovisionedKey does not exist. FixDeprovisionedKey has nothing to do.
deprovisionedKey.DeleteSubKey(packageFamilyName)
deprovisionedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, deprovisionedSD)
deprovisionedKey.KeyExists(packageFamilyName, &isInDeprovisionedKey)
deprovisionKey.CopyTree(nullptr, this->pluginDeprovisionedKey)
deprovisionKey.KeyExists(familyName, packageDeprovisioned)
destination.CreateSubKey(subKeyName, KEY_READ | KEY_WRITE, &destinationSubKey)
destination.SetValue(nameBuffer.GetChars(), valueBuffer.GetBufferPtr(), valueLength, valueType)
Determining if no re-registration of packages is needed failed with 0x%x. We will just default to re-registering all apps.
DeviceIoControl
DEVOBJ.dll
DevObjCreateDeviceInfoList
DevObjDestroyDeviceInfoList
DevObjEnumDeviceInfo
DevObjGetClassDevs
DevObjGetClassDevs(deviceInfoList.get(), &GUID_DEVCLASS_NET, nullptr, DOGCF_PRESENT, nullptr, 0)
DevObjOpenDevRegKey
Did not find cached migration XML, generating new one
Did not find export %s: 0x%x.
Did not find module %s: 0x%x
DirectoryPaths::CreateFullFileName(destDirectory, findFileData.cFileName, &destPath)
DirectoryPaths::CreateFullFileName(sourceDirectory, findFileData.cFileName, &srcPath)
DisableThreadLibraryCalls
DiscoverFailed
DllCanUnloadNow
DllGetClassObject
Doesn't match stub preference while %ws does
Downlevel OS already had package %ws registered for user %ws, writing to UserSid Key
Downlevel OS already had package %ws registered, not writing to Staged Key
downlevelAllUserPackageKey.GetStringValueIfExists(AppxAllUserStore::regValueRegions, &regionsValue, &valueExists)
DownlevelGather
DownlevelInstalled
downlevelInstalledKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
DownlevelOSVersion
DownlevelPackageRepositoryRoot
DownlevelPackageRoot
E(=csm
E;f(r
E0C1)0'
E8=csm
E8f1u
E8f2u
E9f(v)I
Ebgcv
effectivePath.SetValueFromString(expandedPath)
effectivePath.SetValueFromString(offlinePath)
Eh=csm
EH=csm
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
EndOfLife
endOfLifeKey.GetKeySecurity(DACL_SECURITY_INFORMATION, endOfLifeSD)
endOfLifeKey.Open(HKEY_LOCAL_MACHINE, endOfLifePath.GetChars(), KEY_READ)
EnsureACLOnObject(SE_FILE_OBJECT, fullFilePath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_FILE_OBJECT, targetPath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_REGISTRY_KEY, perUserACLPathBuffer.GetChars(), packageContentsSid.get())
EnsureAppRootPermissions(offlineMode)
EnsureAppxDeploymentClientDllLoaded(&deploymentClientModule)
EnsureDelayLoadGetStagedPackagePath()
EnterCriticalSection
EnumAndAddPackagesNotKnownToCapAuth(userSid, packagesToReRegister.Get())
EnumAndAddSubKeysToStringVector(&inboxPackagesKey, packagesToReRegister.Get(), s_PackagesToReRegister)
EnumAndAddSubKeysToStringVector(&userPackagesToRegisterKey, packagesToReRegister.Get(), s_PackagesToReRegister)
EnumerateAndCachePackagesInAllUserStoreUsingGatheredData()
EnumerateUsersAndPopulateUserSids()
Enumerating pre-Win10 packages registered to %s but not known to CapAuth
EnumKey for [%s] failed: 0x%x
EnumValue for [%s] failed: 0x%x
eolPackages->GetCurrent(&package)
error != ERROR_NO_MORE_FILES
Error getting effective rights from ACL for %ws - 0x%x
Error getting SD for %ws - 0x%x
Error retrieving IRepositoryManager 0x%x
Error retrieving IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
Error returned when repairing reg key HKEY_USERS\%s%s
ERROR_INSUFFICIENT_BUFFER != this->GetStagedPackagePathByFullName(packageFullName.GetRawBuffer(nullptr), &packageRootLength, nullptr)
Erroring adding to ACL to %ws - 0x%x
Erroring setting new SD for %ws - 0x%x
EtwEventRegister
EtwEventUnregister
EtwEventWrite
EventRegister
EventSetInformation
EventUnregister
EventWriteTransfer
everyoneSid.Initialize(Common::Deployment::EveryoneSid.chars, Common::Deployment::EveryoneSid.length)
Ex=csm
EX=csm
EX9G$tV
EX9G4t6
Exception
Exclude infused apps failed with 0x%x. Ignoring this error.
Exclude leftover invalid registries failed with 0x%x. Ignoring this error.
Exclude leftover manifest files failed with 0x%x. Ignoring this error.
ExcludeFiles
excludeFilesKey.CreateSubKey(fileName.GetChars(), KEY_READ | KEY_WRITE, &fileKey)
excludeFilesKey.OpenSubKey(file, KEY_READ, &fileKey)
ExcludeInfusedApps
excludeInfusedAppsKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
excludeInfusedAppsKey.OpenSubKey(package, KEY_READ, &packageKey)
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved, existingPreferredPackage->isPaused)
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved, existingPackageIsPaused)
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved, packageIsPaused)
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved, packageIsPaused)
ExcludePackagesWithinKeyUsingGatheredData(&stagedKey, &allUserStoreStagedPath)
ExcludePackagesWithinKeyUsingGatheredData(&userSidKey, &fullPathToUserSidKey)
Excluding InfusedApps folder %ws
exists
Expanded Path value: %s, value length: %u
Expanded SIS path: %s
ExpandEnvironmentStrings(appRepositoryPath, appRepositoryExpandedPath, ARRAYSIZE(appRepositoryExpandedPath)) == 0
ExpandEnvironmentStrings(appRepositoryPath, expandedPath, ARRAYSIZE(expandedPath)) == 0
ExpandEnvironmentStringsW
ext-ms-onecore-appmodel-staterepository-internal-l1-1-2.dll
ext-ms-onecore-appmodel-staterepository-internal-l1-1-6.dll
ext-ms-win-security-capauthz-l1-1-1.dll
f9,Au
f9,Ou
f9<Bu
f9<Qu
f94Cu
f94Ku
fA9,@u
fA9<@u
Failed looking for a cellular modem
Failed processing bundle %s with 0x%x. Ignoring failure to continue with processing
Failed processing framework package %s with 0x%x. Ignoring failure to continue with processing
Failed Processing inbox or devmode package for user with 0x%x. Ignoring failure to continue with processing
Failed processing main package %s with 0x%x. Ignoring failure to continue with processing
Failed processing optional package %s with 0x%x. Ignoring failure to continue with processing
Failed Processing package for user with 0x%x. Ignoring failure to continue with processing
Failed processing resource package %s with 0x%x. Ignoring failure to continue with processing
Failed querying CapAuth for user=%s package=%s: 0x%X
Failed to ApplyTrustLabel - CreateProcess Failed - 0x%x - %s
Failed to ApplyTrustLabel - GetExitCodeProcess Failed - 0x%x - %s
Failed to ApplyTrustLabel - InitializeProcThreadAttributeList Failed - 0x%x - %s
Failed to ApplyTrustLabel - UpdateProcThreadAttribute Failed - 0x%x - %s
Failed to ApplyTrustLabel offline to Plugin Staged Packages - 0X%x
Failed to ApplyTrustLabel offline to Plugin Staged User Acquired Packages - 0X%x
Failed to ApplyTrustLabel offline to PreInstalled Packages - 0X%x
Failed to create per-machine keys 0x%x
Failed to create reg key %ws with 0x%x
Failed to enumerate all users with 0x%x
Failed to enumerate downlevel installed packages for the user %ws with 0x%x, will re-install all apps
Failed to enumerate packages for the user %ws with 0x%x
Failed to exclude file %ws in XML Writer: 0x%x
Failed to exclude registry %ws in XML Writer: 0x%x
Failed to get junction target for : %ws - 0x%x
Failed to get Registry key value [%s]
Failed to get WorkingDir 0x%x
Failed to include directory %ws in XML Writer: 0x%x
Failed to include directory %ws, file %ws in XML Writer: 0x%x
Failed to include registry %ws in XML Writer: 0x%x
Failed to include registry key %ws, value %ws in XML Writer: 0x%x
Failed to merge registry %ws in XML Writer: 0x%x
Failed to merge registry key %ws, value %ws in XML Writer: 0x%x
Failed to move directory %ws to backup folder in XML Writer: 0x%x
Failed to open reg key %ws with 0x%x
Failed to open reg key HKEY_USERS\%s%s, offlineMode: %s
Failed to open sub-key %s of root key %s, hr: 0x%x
Failed to PerformApplySuccessOnlinePerMachineTasks with 0x%x
Failed to process all installed packages with 0x%x
Failed to process all user store packages with 0x%x
Failed to process AppxProvisioning XML for end of life packages 0x%x. Proceeding as if AppxProvisioning XML does not exist so user acquired apps get processed
Failed to process bundle manifest packages: 0x%x. Excluding Bundle.
Failed to processing all packages during AppxUpgradeMigration ApplySuccess with 0x%x
Failed to repair reg value [%s] for package %s, hr: 0x%x
Failed to repair reg value [%s] for reg key %s, hr: 0x%x
Failed to set the FlushInboxCachedManifests in the AppxAllUserStore with 0x%x
Failed to update registry ACLs for '%s': 0x%x.
Failed to write oem uninstalled packages for user %ws with 0x%x
Failed to write out migration XML with 0x%x
Failed to write packages to re-register for user %ws with 0x%x
Failed to write provisioned packages to staged list with 0x%x
Failed with 0x%08lx reading %ws value PackageStatus, assuming package has no in-place update pending
Failed with 0x%x to set %ws key value
FailFast
failureCount
failureId
failureType
FallbackError
false
FamilyName
familyName->GetLength() == familyNameLength
familyName->SetLength(familyNameLength)
familyName->SetValue(fullName, nameLength)
familyNameBuffer.SetValueFromString(familyName.GetChars())
familyNameBuffer.SetValueFromString(packageFamilyName)
familyNameBuilder.AppendString(cursor)
fB9<[u
fD9 t
fD9!H
fD9$Au
fD9$Ou
fD9$yu
fD9(t
fD9,Vu
fD9,wu
fD9/A
fD9}ot>D8}g
fD9+tRH
fD9+ts
fD9+u
fD9<Au
fD98t
fD9e8A
fD9t}
fD9u 
fD9u@u
fD9u0
fD9u8
fE9 H
fE9,Au
fE9<Pu
fF9$Bu
ffD9u0
fg:SM
File %s in working dir: %s
File: %ws
FileDescription
fileKey.GetStringValue(s_Path, &filePath)
fileKey.SetStringValue(s_Path, fullFilePath.GetChars())
fileName
fileName.SetLength(fileName.GetLength() - wcslen(L".xml"))
fileName.SetValueFromString(findFileData.cFileName)
fileNameBuilder.AppendChar('\\')
fileNameBuilder.AppendString(expandedPath)
filenameBuilder.AppendString(OSRollbackPackagesFilename)
fileNameBuilder.AppendString(stateRepositoryMachineDatabase)
fileNameBuilder.AppendString(stateRepositoryWalFile)
filenameBuilder.AppendString(workingDir)
FileVersion
FindClose
FindFirstFileW
findMethod(packageInfoCollection.GetAddressOf())
FindNextFileW
Finished AppxUpgradeMigration ApplySuccess for %s with 0x%x
Finished AppxUpgradeMigration ApplySuccess offline with 0x%x
FixDeprovisionedKey(pluginAllUserStoreKey)
FixDeprovisionedKey: Deprovisioned key has %ws, while Applications key has %ws. Deleting package from Deprovisioned key.
Fixing
FixStateRepositoryIfPossible called
FixStateRepositoryIfPossible completed Disposition=%d
FixStateRepositoryIfPossible failed (0x%x) Disposition=%d
FixStateRepositoryIfPossible(disposition)
FixStateRepositoryIntegrity(repositoryManager)
FixStateRepositoryIntegrityCompleted
FixStateRepositoryOrResetMaintenance already executed
FixStateRepositoryOrResetMaintenance called
FixStateRepositoryOrResetMaintenance done
FixStateRepositoryOrResetMaintenance()
FixStateRepositoryViaExport(disposition)
FixStateRepositoryViaRepositoryManager called
FixStateRepositoryViaRepositoryManager done. Disposition %d
FixStateRepositoryViaRepositoryManager(disposition)
FlushInboxCachedManifests
folderPathBuilder.AppendString(backupFolderNameWithSlash)
folderPathBuilder.AppendString(fullName)
folderPathBuilder.AppendString(L"\\")
folderPathBuilder.AppendString(systemMetadataFolder)
folderPathBuilder.AppendString(this->singleInstanceStore.GetChars())
FormatMessageW
Found bad path in reg key value [%s] that needs repair: %s
Found cached migration XML
Found Ghosts Entries: %d. Repaired Ghost Entries: %d.
Found IRepositoryManager
Found IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
framework
Framework
Framework package is paused so its package root and backup manifest will be excluded
frameworkPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
frameworksPathBuilder.AppendString(Common::Deployment::frameworksDir)
frameworksPathBuilder.AppendString(infusedAppsFolder.GetChars())
FreeLibrary
fullFilePath->SetValue( moduleFullPath, static_cast<ULONG>(lastBackslash + 1 - moduleFullPath))
fullFilePathBuilder.AppendString(expandedSystem32Path)
fullFilePathBuilder.AppendString(findFileData.cFileName)
fullFilePathBuilder.AppendString(L"\\")
fullFilePathBuilder.AppendString(packagePath)
fullFilePathBuilder.AppendString(path)
fullFilePathBuilder.AppendString(this->packageRepository.GetString())
fullFilePathBuilder.AppendString(this->singleInstanceStore.GetChars())
FullName
fullName.Initialize(packageFullName)
fullNameAsString.Initialize(packageFullName)
fullNameBuffer.SetValueFromString(fullName)
fullNameBuffer.SetValueFromString(fullNameToWrite)
function
Fy}vU
g 44B'
g#\!R
Gather.FixStateRepositoryOrResetMaintenance.Failed
GatherDataForExcludeAllInfusedApps()
GatherDataForExcludeAllInfusedAppsInFolder(applicationsFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(frameworksFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(packagesFolder.GetChars())
GatherDataForExcludeLeftoverManifestFiles()
GatherDataForProcessAllBundleResourceAndOptionalPackages()
GatherDataForProcessAllInstalledPackages()
GatherDataForProcessAllMainAndFrameworkPackages()
GatherDataForProcessAllUserStorePackages()
GatherDataForProcessBundleManifestPackages(packageFullName)
GatherDataForProcessPackagesForUser(this->userSids.At(i)->GetChars())
GatherDataForWriteOutPerMachineMigrationXml()
GatherDownlevelData()
GatherFailed
Gathering bundle manifest data for %s
Gathering data for bundle %s
Gathering data for main or framework package %s
Gathering data for optional package %s
Gathering data for resource package %s
Gathering data for user package %s
Gathering install state for package %s
Gathering packages installed for user %s
GatherInstallStateForAllPackages()
GatherInstallStateForPackage(packageManager.Get(), package, packageFullName, installStateRootKey)
GatherPackageDataForUser(packageManager.Get(), package, packageFullName, userSid, packageKey)
GatherSingleInstanceStoreDirectories()
GenerateSystemMigrationXml(xmlStream)
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetEffectiveRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), offlineMode, effectiveAllUserStorePathBuffer, effectiveAllUserStorePath)
GetEffectiveRegistryPath(RegistryHive::HKLM, packageRepositoryPackagesKeyPath, offlineMode, effectivePackageRepositoryPackagesKeyPathBuffer, effectivePackageRepositoryPackagesKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginKeyPathBuffer, effectivePluginKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginPathBuffer, effectivePluginPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineMode, effectivePluginPathBuffer, effectivePluginPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, stubPreferenceKeyPath, offlineExecution, effectiveStubPreferenceKeyPathBuffer, effectiveStubPreferenceKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKU, perUserRegistryPathBuffer.GetChars(), offlineMode, effectivePerUserRegistryPathBuffer, effectivePerUserRegistryPath)
GetEffectiveRegistryPath(RegistryHive::HKU, userPath.GetChars(), offlineMode, effectiveUserPathBuffer, effectiveUserPath)
GetEffectiveRightsFromAclW
GetExitCodeProcess
GetFamilyNameFromFullName(fullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &packageFamilyName)
GetFamilyNameFromFullName(subKey, &packageFamilyName)
GetFamilyNameFromFullName(WindowsGetStringRawBuffer(packageFullName, nullptr), &packageFamilyName)
GetFileAttributesW
GetFileVersionInfoEx(FILE_VER_GET_LOCALISED | FILE_VER_GET_NEUTRAL, appxUpgradeMigrationPluginFileName, 0, versionSize, versionData)
GetFileVersionInfoExW
GetFileVersionInfoSizeExW
GetIfEntry2
GetInboxOrDevModePackageManifestPath(packageRootPath, manifestPath)
GetInstalledBundleForUser(packageFamilyName, userSid, &bundleName)
GetIsInboxPackageUsingGatheredData(packageFullName, &isInboxPackage)
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(familyName.GetChars(), false , &packageDeprovisioned)
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(packageFamilyName, false , &packageDeprovisioned)
GetIsStubPreferredForPackageFamilyUsingGatheredData(familyName.GetChars(), &preferStubForFamily)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName, &preferStub)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName.GetChars(), &downlevelPreference)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName->GetChars(), &preferStubForFamily)
GetLastError
GetMetadataFolderForPackage(fullName, false , &metadataFolder)
GetMetadataFolderForPackage(fullName, true , &metadataFolderInSharedLimitedTime)
GetModuleFileName failed 0x%x -- unable to create full file path for %s
GetModuleFileNameW
GetModuleHandleW
GetNamedSecurityInfoW
GetOfflineFilePath(packagePath.GetChars(), &offlinePackagePath)
GetOfflineFilePath(this->singleInstanceStore.GetChars(), &offlineSystemSisPath)
GetOfflineRegistryPath(hive, path, &resultBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePath.GetChars(), &offlineAllUserStorePath)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), &offlineAllUserStorePathBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, c_messagingKeyPath, &offlineAppxRegKeyPath)
GetOfflineRegistryPath(RegistryHive::HKLM, Common::Deployment::AppXRegKeyPath.chars, &offlineAppxRegKeyPath)
GetOfflineRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, &regPath)
GetOfflineRegistryPath(RegistryHive::HKLM, softwareHive, &offlineSoftwareHive)
GetPackageDirectoryExistsUsingGatheredData(fullName, &exists)
GetPackageDirectoryExistsUsingGatheredData(packageFullName, &exists)
GetPackageInstalledPath(package, packageRootPath)
GetPackageInstallState(packageManager, fullName, nullptr , &packageInstallState)
GetPackageInstallState(packageManager, fullNameAsString, userSid, &packageInstallState)
GetPackageIsPausedUsingGatheredData(packageFullName, &packageIsPaused)
GetPackageIsPausedUsingGatheredData(provisionedInstalledPackageFullName, &provisionedInstalledPackageIsPaused)
GetPackageIsStubUsingGatheredData(packageFullName, &packageIsStub)
GetPackageIsStubUsingGatheredData(provisionedInstalledPackageFullName, &provisionedInstalledPackageIsStub)
GetPersistedRegistryLocationW
GetPluginHasExecutedOffline(executedOffline)
GetPluginHasExecutedOffline: %d for context %ws
GetPluginHasExecutedOfflineValueName(valueName)
GetPluginRelativeFullPath(L"", &manifestPathBuffer)
GetProcAddress
GetProcessHeap
GetServiceStatus(serviceName, &status)
GetStagedPackagePathByFullName
GetStubPreferenceFromKey(stubPreferenceKey, familyName.GetChars(), &packageIsStub)
GetStubPreferenceFromKey(stubPreferenceKey, packageFamilyName, &uplevelProvisionedPackageIsStub)
GetStubPreferenceFromKey(stubPreferenceKey, packageFamilyName->GetChars(), &packageIsStub)
GetStubPreferenceFromKey(stubPreferenceRootKey, packageFamilyName, stubPreferred)
GetStubPreferenceFromKey(uplevelStubPreferenceKey, packageFamilyName.GetChars(), &uplevelPreference)
GetStubPreferenceKey(KEY_READ | KEY_WRITE, uplevelStubPreferenceKey)
GetStubPreferenceKey(KEY_READ, stubPreferenceKey)
GetSystem32FullPath(applyTrustLabelApplication, &applyTrustLabelAppFullPath)
GetSystemSisManifestPathFromPackageFullName( bundleFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName( packageFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName(packageToWrite, &packageManifestPath)
GetSystemTimeAsFileTime
GetSystemWindowsDirectory(systemWindowsDirectory, ARRAYSIZE(systemWindowsDirectory)) == 0
GetSystemWindowsDirectoryW
GetTickCount
GetTickCount64
Getting single instance store path failed with %x, switching to use legacy location
Getting stub preference key with offlineExecution: %d
Getting stub preference key. stubPreferenceKeyPath:  %ws
GetVersionInfo(&osVersion)
H UATAUAVAWH
h UAVAWH
H!\$ H
H!\$(H!\$ H
H!\$0A
H!\$0H!\$(H!\$ 3
H!\$83
H!\$8D
H!\$8H!\$0H!\$(H!\$ 3
H!\$8H!\$0H!\$(H!\$ L
H!\$8L
H!|$8H!|$0H!|$(H!|$ 3
H!|$x
H!t$x
H_^[]
H`>sC
Has same main package as %ws
HasCellularModem
HasModem
HcD$$H
HcL$ H
HeapAlloc
HeapFree
HKCU\
HKLM\
hrActivateInstance
hrAllUserStoreKeySetKeySecurity
hrAppendFullName
hrApplyTrustLabelToPackages
hrApplyTrustLabelToPluginStagedPackages
hrApplyTrustLabelToPluginStagedUserAcquiredPackages
hrApplyTrustLabelToPreInstalledPackages
hrAppxPreRegisterPackage
hrCleanupOrphanPackages
hrCleanupSystemAppsMigratedToFOD
hrCopyBackupManifestForEndOfLifePackagesIfNecessary
hrCopyMetadataIfRequired = CopyMetadataIfRequired()
hrCreateKey
hrCreatePerMachineKeys
hrCreateProvisionStreamingReaderFromFile
hrDeleteOSRollbackPackagesRegistry
hrDeprovisionedKeySetKeySecurity
hrEndOfLifeKeySetKeySecurity
hrEnsureAutogenDeleted
hrEnsureRegistryKeyPermissions
hrEnumBundles
hrEnumerate
hrEnumerateUsersAndPopulateUserSids
hrEnumFamilies
hrEnumFrameworks
hrEnumMainPackages
hrEnumOptionalPackages
hrEnumPackages
hrEnumResourcePackages
hrEnumSubfolders
hrEnumSubkeys
hresult
HResult
HRESULT_FROM_WIN32(enumResult)
HRESULT_FROM_WIN32(GetLastError())
hrExcludeAllInfusedApps
hrExcludeFile
hrExcludeKey
hrExcludeLeftoverInvalidRegistries
hrExcludeLeftoverManifestFiles
hrGatherData
hrGetPackageIDFromPackageMoniker
hrGetProvisionXmlPath
hrGetTarget
hrGetValue
hrGetWorkingDir
hrIncludePath
hrIncludeRegistryKey
hrIncludeRegistryValue
hrInitializeUpgradeData
hrIterateBundles
hrIterateOptionalPackages
hrIteratePackages
hrIterateResourcePackages
hrMarkUplevelProvisionedPausedPackagesAsStaged = MarkUplevelProvisionedPausedPackagesAsStaged()
hrMergeRegistryKey
hrMergeRegistryValue
hrMovePathToBackupFolder
hrOpenKey
hrOpenPackagesToRemove
hrPluginAppxKeyOpen
hrPluginAppxKeyOpenAppxAllUserStore
hrPluginAppxKeyOpenSubKeyApplications
hrPluginOpenPackagesToCheckForStagingCompletion
hrPluginOpenPackagesToReRegister
hrPopulateAppxProvisionXmlLists
hrPreRegister
hrPreRegisterAllPackages
hrProcessAllInstalledPackages
hrProcessAllUserStorePackages
hrProcessBundleManifestPackages
hrProcessInboxOrDevModePackageForUser
hrProcessPackage
hrProcessPackageForUser
hrProcessRecoveryData
hrProcessSingletonPackages
hrReadAppXMigrationStores
hrReIndexPackagesForFeatureLightUp = ReIndexPackagesForFeatureLightUp()
hrRemoveUplevelProvisionedUnneededPackages = RemoveUplevelProvisionedUnneededPackages()
hrRepairBadPathsInHKU
hrRepairPackageRepository
hrRepairPackageRootFolderPath
hrRepairStateRepository
hrSavePackageListFromFileToRegistry
hrSetupPackagesForReRegistration
hrSetValue
hrStagedKeySetKeySecurity
hrUserPackagesToReRegisterKey
hrWrite
hrWriteAllUserStoreKeys
hrWriteFrameworkMap
hrWriteOutPerMachineMigrationXml
hrWriteOutPerUserMigrationXml
hrWritePackagesToReRegisterKeys
hrWriteResourceMap
hrWriteUninstalledKeys
http://schemas.microsoft.com/appx/2013/appxprovisionpackage
If the OS doesn't support packageManager2 interface then no resource and bundles can be installed--no bundles and resources to process. 
Ignoring error: Package %ws failed to ensure deleted Autogen: 0x%x
Ignoring error: Package %ws failed to preregister: 0x%x
Ignoring package %ws with unknown property type %x
ImportPackageUserStatusToStateRepository imported status from %d packages and failed to import status from %d packages
ImportPackageUserStatusToStateRepository(userSidString)
InboxApplications
inboxPackagesKey.Open(HKEY_LOCAL_MACHINE, inboxPackagesBuffer.GetChars(), KEY_READ)
infusedPathBuilder.AppendString(Common::Deployment::infusedAppsDir)
infusedPathBuilder.AppendString(systemWindowsDirectory)
InitializeCmdLine(applicationPath, offlineSoftwareHive, cmdLineBuilder)
InitializeCriticalSection
InitializeCriticalSectionEx
InitializePackageRepositoryRoot()
InitializePluginRegistryKeys(offlineExecution, &appxKeyFound)
InitializeProcThreadAttributeList
InitializeSRWLock
InitializeSystemSisFullPath()
InitOnceBeginInitialize
InitOnceComplete
Inserting %ws since it was brought by a bundle %ws
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , false , &comparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , true , &comparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , true , &packagePreferenceComparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &versionlessName, &this->frameworkMap, false , false )
InsertToPreferredMapUsingGatheredData(fullName, &familyNameBuffer, &this->combinedProvisionedMap, true , false , &comparison)
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, &this->frameworkMap, true , false )
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, &this->resourceMap, true , false )
InsertToPreferredMapUsingGatheredData(packageFullName, &versionlessName, &this->resourceMap, false , true )
InSingleInstanceStore
installedLocation.As(&installedLocationStorageItem)
installedLocationStorageItem->get_Path(packagePath.ReleaseAndGetAddressOf())
InstalledPackages
installedPackagesKey.CreateSubKey(s_Bundle, KEY_READ | KEY_WRITE, &bundlesKey)
installedPackagesKey.CreateSubKey(s_Framework, KEY_READ | KEY_WRITE, &frameworkPackagesKey)
installedPackagesKey.CreateSubKey(s_Main, KEY_READ | KEY_WRITE, &mainPackagesKey)
installedPackagesKey.CreateSubKey(s_Optional, KEY_READ | KEY_WRITE, &optionalPackagesKey)
installedPackagesKey.CreateSubKey(s_Resource, KEY_READ | KEY_WRITE, &resourcePackagesKey)
installedPackagesKey.OpenSubKey(s_Bundle, KEY_READ, &bundlesKey)
installedPackagesKey.OpenSubKey(s_Framework, KEY_READ, &frameworkPackagesKey)
installedPackagesKey.OpenSubKey(s_Main, KEY_READ, &mainPackagesKey)
installedPackagesKey.OpenSubKey(s_Optional, KEY_READ, &optionalPackagesKey)
installedPackagesKey.OpenSubKey(s_Resource, KEY_READ, &resourcePackagesKey)
InstallState
installStateKey.OpenSubKeyIfExists(provisionedPackageFullName, KEY_READ, &packageKey)
installStateRootKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
installStateRootKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &packageKey)
InternalName
INVALID_HANDLE_VALUE == deviceInfoList.get()
IPHLPAPI.DLL
Is a framework package
Is a LOB app
Is a main or bundle package
Is a resource package
Is a top level package
Is being DROPPED because it is a de-provisioned package
Is higher version than %ws
Is less preferred than %ws
Is lower version than %ws
Is more preferred than %ws
Is same version as %ws
IsDebuggerPresent
IsDevModeApp
IsFixStateRepositoryAlreadyExecuted(alreadyExecuted)
IsFramework
IsLOBApp
IsPackageInEndOfLifeKey(endOfLifeMissingManifestFixablePackageFullNames[i], &isInEndOfLifeKey)
IsPackageRegistrationPreservedAcrossUpgrade()
IsPluginDeprovisionedPackage(&allUserStoreKey, packageFamilyName, &isDeprovisioned)
IsStub
IUIPolicyChecked
J>f;O
Keep thread running start.
KERNEL32.dll
kernelbase.dll
key.Open(HKEY_LOCAL_MACHINE, effectiveStubPreferenceKeyPath, access)
key.OpenSubKeyIfExists(packageFamilyName, KEY_READ, &packageFamilyKey)
key.ValueExists(valueName.GetChars(), &hasExecutedOffline)
key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)
key->OpenSubKey(userSid, KEY_READ, &userSidKey)
keysToDelete.Add(uplevelPackageToDelete)
L!d$8L!d$0L!d$(L!d$ L
l$ E3
L$ SVWAVH
L$ SVWH
L$ UVWATAUAVAWH
L$ VWATAVAWH
l$ VWAVH
L$ VWAVH
l$ VWAVH
L$(E3
L$@H!\$0L
L$@H3
L$@I+
L$`9L$Pu
L$`D;
L$`E3
L$`fA;
L$`H3
L$0E3
L$0H3
L$8E3
L$hH3
L$PD8
L$PH;
L$XfD
L$XL+
L9{Hu
L9|$8u
L9|$Hu
L9|$xu
L9}@uw
L9d$`u
L9m@tX3
L9t$Hu
L9t$xu
L9u@L
LastReturnValue
LcA<E3
LeaveCriticalSection
LegalCopyright
lineNumber
Loading ext-ms-win-security-capauthz-l1-1-1.dll
LoadLibraryExW
LoadLibraryW
LoadUpgradeDataFromPluginKey()
Local\SM0:%lu:%lu:%hs
LocalFree
LocationModifyStringForInfusedApps
LocationModifyStringForWindowsApps
LOG_IF_FAILED(%S) failed with 0x%x
LOG_IF_FAILED_MSG(%S) failed with 0x%x. Message is below:
LogHr
LogNt
lpt1.
lpt2.
lpt3.
lpt4.
lpt5.
lpt6.
lpt7.
lpt8.
lpt9.
m:AppxProvisionList
m:AppxProvisionList/m:EndOfLife/m:Package/@FamilyName
m:AppxProvisionList/m:Provisioned/m:Package/@FullName
m:EndOfLife
m:EndOfLife/m:Package
m:Package
m:Provisioned
m:Provisioned/m:Package
M0K0I
MACHINE
Main package
mainPackageKey.GetUInt32ValueIfExists(AppxAllUserStore::regValueIsLOBApp, &isLOBApp, &valueExists)
mainPackageKey.SetStringValue( AppxAllUserStore::regValuePath, packageManifestPath.GetStringRef())
mainPackageKey.SetStringValue(AppxAllUserStore::regValueRegions, regionsValue.GetChars())
mainPackageKey.SetUInt32Value(AppxAllUserStore::regValueIsLOBApp, 1)
mainPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
MaintenanceLastPerformed
malloc
ManifestCacheOptions
manifestPackageID->GetPackageFullName(&packageFullName)
manifestPath.SetValueFromString(packageRoot.GetRawBuffer(nullptr))
manifestPathBuilder.AppendChar(L'\\')
manifestPathBuilder.AppendString(&Common::Deployment::BundleManifestFileName)
manifestPathBuilder.AppendString(&Common::Deployment::ExtendedPathPrefix)
manifestPathBuilder.AppendString(&Common::Deployment::ManifestFileName)
manifestPathBuilder.AppendString(packageFullName)
manifestPathBuilder.AppendString(this->singleInstanceStore.GetChars())
Matches stub preference while %ws doesn't
memcmp
memcpy
memcpy_s
memmove
memmove_s
memset
message
messagingKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_READ)
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_WRITE)
metadataPathBuilder.AppendString(fullName)
metadataPathBuilder.AppendString(sisPath)
metadataPathBuilder.AppendString(systemMetadataFolder)
Microsoft
Microsoft Corporation
Microsoft Corporation1
Microsoft Corporation1&0$
Microsoft Corporation1)0'
Microsoft Corporation1.0,
Microsoft Corporation1200
Microsoft Time-Stamp PCA 2010
Microsoft Time-Stamp PCA 20100
Microsoft Time-Stamp Service
Microsoft Time-Stamp Service0
Microsoft Windows0
Microsoft.CommsPhone_8wekyb3d8bbwe
Microsoft.Messaging_8wekyb3d8bbwe
Microsoft.OneConnect_8wekyb3d8bbwe
Microsoft.Windows.AppxMigrationPlugin
Microsoft.Windows.SecondaryTileExperience_10.0.0.0_neutral__cw5n1h2txyewy
Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\
MigrateDownlevelStubPreference()
MigXml
MigXmlWriter::Create(false , nullptr, &xmlWriter)
MigXmlWriter::Create(true , &this->pluginDownlevelGatherKey, &xmlWriter)
MigXmlWriter::GatherDataForEnvironmentStrings(this->pluginDownlevelGatherKey)
module
Msg:[%ws] 
msvcrt.dll
N0L0J
nameBuffer.SetCapacity(nameBufferLength)
NetCfgInstanceId
neutral
NewParser
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
No %s found - cannot apply trust labels
No Applications Plugin key found--downlevel had no OEM apps or newer all-user apps to copy over
No need to write Applications Key because uplevel provisioned package %ws is the most preferred version
No PackagesToCheckForStagingCompletion Plugin key found
No PackagesToRemove Plugin key found
No PackagesToReRegister Plugin key found
No Plugin Applications key found. Downlevel had no OEM apps or newer all-user apps to copy over
No Plugin key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin key found--downlevel had no apps or Discover/Gather failed.
No Plugin Staged key found. As far as we know, user had no packages to ApplyTrustLabel
No Plugin Staged key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin StagedUserAcquired key found. As far as we know, User had no packages
No Plugin StagedUserAcquired key found. As far as we know, user had no packages to ApplyTrustLabel
No work to do for DEFAULT user. Skipping.
NoReRegisterOnUpgrade
not found
Not generating migration XML on downlevel system since new packages can still be provisioned on uplevel image.  Migration XML will be generated during Discover on uplevel system.
Not Removing up-level provisioned deprovisioned Package because a user has it still installed: %ws
NtClose
NtCreateSection
ntdll.dll
NtMapViewOfSection
NtQueryWnfStateData
NtUnmapViewOfSection
NtUpdateWnfStateData
O0M0K
offlineFilePath->SetValueFromString(reinterpret_cast<PCWSTR>(bstrOfflineFilePath.Value()))
offlinePathBuilder.AppendChar(L'\"')
offlinePathBuilder.InsertChars(0, L" \"", 2)
offlineRegistryPath->SetValueFromString((reinterpret_cast<PCWSTR>(bstrOfflineRegistryPath.Value())) + hivePrefixLength)
OLEAUT32.dll
onecore\admin\appmodel\appxupgrademigrationplugin\src\appxupgrademigrationpluginclass.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\AppxUpgradeMigrationPluginClass.h
onecore\admin\appmodel\appxupgrademigrationplugin\src\migxmlwriter.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\recoveryreader.cpp
onecore\admin\appmodel\common\alluserstorepaths.cpp
onecore\admin\appmodel\common\configuration.cpp
onecore\admin\appmodel\common\directorypaths.cpp
onecore\admin\appmodel\common\downlevelhelper.cpp
onecore\Admin\appmodel\Common\ManifestCache.hpp
onecore\admin\appmodel\common\mountedfolder.cpp
onecore\admin\appmodel\common\packagefullnameutilities.cpp
onecore\Admin\appmodel\common\PackageID.inl
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackage.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackageenumerator.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionreader.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionwriter.cpp
onecore\base\appmodel\appxprovisionpackage\src\commonhelpers.cpp
onecore\base\appmodel\common\autocotaskmemstring.cpp
onecore\base\appmodel\common\bytebuffer.cpp
onecore\base\appmodel\common\pathhelpers.cpp
onecore\base\appmodel\common\registrykey.cpp
onecore\base\appmodel\common\stateseparation.cpp
onecore\base\appmodel\common\stringbuilder.cpp
onecore\base\appmodel\common\stringset.cpp
onecore\base\appmodel\common\widestring.cpp
onecore\internal\base\inc\appmodel\package\ProcessorArchitecture.hpp
onecore\internal\sdk\inc\wil/Staging.h
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
opcFactory->CreateStreamOnFile( manifestPath.GetChars(), OPC_STREAM_IO_READ, NULL, FILE_ATTRIBUTE_NORMAL, &manifestStream)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, false , &file)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, true , &fileHandle)
Opening reg key HKEY_LOCAL_MACHINE\%s to enumerate
Opening reg key HKEY_USERS\%s to enumerate
Opening the effective stub preference key path: %ws
OpenPerUserClassesSubKey(userSid, appxMiniRepositoryPackagesSubkey, offlineMode, &packagesKey)
OpenPerUserSubKey(userClassesKeyName.GetChars(), subKey, offlineMode, registryKey)
OpenPerUserSubKey(userSid, rootKeyPath, offlineMode, &rootKey)
OpenSCManagerW
OpenSemaphoreW
OpenServiceW
Optional
optionalPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
OriginalFilename
originatingContextId
originatingContextMessage
originatingContextName
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running ApplySuccess.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Discover.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Gather.
OSDATA\Software\
OSRollbackPackages
OutputDebugStringW
OverrideConfig
p AWH
p WATAUAVAWH
p WAVAWH
p WvA>
p)W\j
p0R^G'
PA^_]
PA^_^
pA^_^[]
PA^A\_^]
PA_A^_
pA_A^_^]
PA_A^_^]
pA_A^A\_^[]
pA_A^A]A\_^]
PA_A^A]A\_^]
Package
Package %ws destage completed with hr = 0x%x.
Package %ws does not exist in SIS. Don't carry it forward
Package %ws has an in-place update pending, can't move it away.
Package %ws is being end of lifed so its package root will be excluded
Package %ws is End Of Life and missing a backup manifest, but we could not fix this.
Package %ws is End Of Life and was missing a backup manifest, but we were able to replace the backup manifest.
Package %ws is not needed, not writing to Staged Key
Package %ws will be preserved because package registration is preserved
Package family %ws does not exist in SIS. Don't carry it forward
Package family %ws is end-of-lifed
Package family not found yet, adding new entry
Package is being end of lifed so its package root will be excluded
Package is in paused state. This package will be treated the same as if it were staged
Package is LOB and will be carried forward.
Package is not uplevel provisioned or LOB and will be carried forward. Since it's downlevel provisioned, but not uplevel provisioned implies this is an OEM package
Package is uplevel provisioned.
Package root of %ws will be excluded as it is less preferred
package->get__PackageID(&packageId)
package->get_IsFramework(&isFramework)
package->get_NeedsSingletonRegistration(&needsSingletonRegistration)
package->get_PackageFullName(&packageFullName)
package->GetPackageFamilyName(&familyName)
package->GetPackageFullName(&fullName)
package->GetPackageId(&manifestPackageID)
package->GetPackageType(&packageType)
package->GetProperties(&packageProperty)
package8->get_InstalledPath(packagePath.ReleaseAndGetAddressOf())
package8->get_IsStub(&isStub)
packageFamilyKey.CopyTree(nullptr, allUserApplicationsKey)
packageFamilyKey.GetUInt32ValueIfExists(s_PreferStub, &value, &valueExists)
packageFamilyKey.SetUInt32Value(s_PreferStub, downlevelPreference)
packagefamilyNameAsInternalString.Initialize( packageFamilyName, static_cast<ULONG>(wcslen(packageFamilyName)))
PackageFamilyNameFromFullName
packageFullName
packageFullNameKey.GetStringValue(s_Path, &packagePath)
packageFullNames->get_Size(&size)
packageFullNames->GetAt(index, packageFullName.GetAddressOf())
packageFullNamesToReRegister->Append(packageFullName)
packageId->get_FullName(packageFullName.GetAddressOf())
packageId->get_FullName(packageFullNameAsString.GetAddressOf())
packageInfo->get_Id(&packageId)
packageInfo->get_InstalledLocation(&installedLocation)
packageInfo->get_IsFramework(&isFrameworkValue)
packageInfoCollection->First(packageInfoIterator.GetAddressOf())
packageInfoIterator->get_Current(packageInfo.GetAddressOf())
packageInfoIterator->get_HasCurrent(&hasCurrent)
packageInfoIterator->MoveNext(&hasCurrent)
PackageInstallState
packageKey.GetStringValue(s_PackageRoot, &packageRoot)
packageKey.GetStringValue(s_Path, &packageFullPath)
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeKeyString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeNameString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeKeyString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeNameString, &value, &valueExists)
packageKey.GetStringValueIfExists(s_BundleFullName, bundleFullName, &hasBundle)
packageKey.GetUInt32Value(s_InSingleInstanceStore, &inSingleInstanceStoreValue)
packageKey.GetUInt32Value(s_InstallState, &packageInstallState)
packageKey.GetUInt32Value(s_IsFramework, &isFrameworkValue)
packageKey.GetUInt32Value(s_PackageType, &packageType)
packageKey.GetUInt32ValueIfExists(s_InstallState, &packageInstallState, &valueExists)
packageKey.GetUInt32ValueIfExists(s_IsStub, &isStubValue, &valueExists)
packageKey.SetStringValue(pathValueName, expandedPath)
packageKey.SetStringValue(s_BundleFullName, bundleName.GetChars())
packageKey.SetStringValue(s_PackageRoot, manifestPath.GetChars())
packageKey.SetStringValue(s_Path, packageFullPath)
packageKey.SetUInt32Value(s_InSingleInstanceStore, inSingleInstanceStore ? 1 : 0)
packageKey.SetUInt32Value(s_InstallState, packageInstallState)
packageKey.SetUInt32Value(s_IsFramework, isFrameworkValue ? 1 : 0)
packageKey.SetUInt32Value(s_IsStub, isStub)
packageKey.SetUInt32Value(s_PackageType, packageType)
PackageList
packageManager->FindPackagesByUserSecurityId(userSidAsInternalString, collection)
packageManager->FindUsers(packageFullName, userInfoCollection.GetAddressOf())
packageManager->SetPackageStatusBlocking(packageFullName)
packageManager->SetupOutdatedPackagesForReRegistration(userSidString.Get(), packagesToReRegister.Get())
packageManager2.As(&packageManager)
packageManager2->FindPackagesByUserSecurityIdPackageFamilyNameWithPackageTypes( userSidAsInternalString, packagefamilyNameAsInternalString, Windows::Management::Deployment::PackageTypes_Bundle, collection)
packageManifestPath->InitializeFromString(manifestPath.GetChars())
packagePath.Initialize(packageRoot.get(), packageRootLength)
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxBundleManifestRelativePath) - 1))
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxManifestRelativePath) - 1))
PackageRepositoryRoot
PackageRoot
packageRoot.SetLength(packageRootLength)
packageRootBuilder.AppendChar(L'\\')
packageRootBuilder.AppendString(package)
PackageRootFolder
Packages
packages->GetCurrent(&package)
packagesKey.Open(HKEY_LOCAL_MACHINE, effectivePackageRepositoryPackagesKeyPath, KEY_READ | KEY_WOW64_64KEY)
packagesKey.OpenSubKey(packageFullName.GetChars(), KEY_READ | KEY_WRITE, &packageKey)
packagesPathBuilder.AppendString(Common::Deployment::packagesDir)
packagesPathBuilder.AppendString(infusedAppsFolder.GetChars())
packageStatics->Find(&packages)
packageStatics->FindPackageFullNamesByUserSidAndPackageTypeAndTargetDeviceFamily( userSidAsHString.Get(), Windows::Internal::StateRepository::PackageType_Main, DEVICEFAMILYINFOENUM_WINDOWS_8X, &packageFullNames)
packageStatics->UpdateIsSingletonRegistered(packageId, false)
PackageStatus
PackagesToCheckForStagingCompletion
PackagesToCheckForStagingCompletion: %ws
packagesToCheckForStagingCompletion->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
PackagesToRemove
PackagesToReRegister
packagesToReRegister->get_Size(&vectorCount)
packageSubKey->SetValueFromString(packageFullName)
packageSubKeyBuilder.AppendChar(L'\\')
packageSubKeyBuilder.AppendString(packageFamilyName)
packageSubKeyBuilder.AppendString(packageFullName)
packageSubKeyBuilder.AppendString(packageToWrite)
packageSubKeyBuilder.AppendString(userSid)
PackageType
PackageVolumeKey
PackageVolumeName
PartA_PrivTags
pathBstr.CopyFromString(path)
pathBuilder.AppendChar('\\')
pathBuilder.AppendChar(L'\\')
pathBuilder.AppendString(&RecoveryReader::recoveryExtension)
pathBuilder.AppendString(appRepositoryExpandedPath)
pathBuilder.AppendString(autogenDirectorySubPath)
pathBuilder.AppendString(Common::Deployment::ManifestFileName.chars)
pathBuilder.AppendString(familyName)
pathBuilder.AppendString(fullName)
pathBuilder.AppendString(L"\\")
pathBuilder.AppendString(packageFullName)
pathBuilder.AppendString(path)
pathBuilder.AppendString(path->GetString())
pathBuilder.AppendString(systemMetadataDirectoryForPackage)
pathBuilder.AppendString(systemMetadataFolder)
pathBuilder.AppendString(upgradePath.GetString())
pathBuilder.AppendString(userSid)
Paused package %ws will be preserved as it will likely be the best version when it completes 
pcPZt
PerformApplySuccessPerMachineTasks(false )
PerformApplySuccessPerMachineTasks(true )
PerformApplySuccessPerUserTasks(userSidString, false )
PerformApplySuccessPerUserTasks(userSidString, true )
Performing AppxUpgradeMigration Plugin offline tasks
perUserACLPathBufferBuilder.AppendString(effectivePerUserRegistryPath)
perUserACLPathBufferBuilder.AppendString(L"USERS\\")
perUserInstalledKey.CreateSubKey(package, KEY_READ | KEY_WRITE, &perUserInstalledSubKey)
perUserInstalledSubKey.SetUInt32Value(lastReturnValueRegistryValueName, S_OK)
perUserRegistryPathBufferBuilder.AppendString(appContainerStorageRegistrySubKey)
perUserRegistryPathBufferBuilder.AppendString(registryClassesPrefix)
perUserRegistryPathBufferBuilder.AppendString(userSid)
perUserReRegistrationKey.CreateSubKey(mainPackageFullName, KEY_READ | KEY_WRITE, &perUserReRegistrationSubKey)
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
pL9}@tRD8
Plugin Appx key not found which should be present on up-level -- abandoning FixStateRepositoryIntegrity.
Plugin registry key after Gather:
Plugin sub key found -- we're on uplevel system during apply phase for system context. Generate MigXml for Discover.
Plugin sub key found -- we're on uplevel system during apply phase for user context. Skip running Discover.
pluginAllUserStoreKey.OpenSubKey(s_Applications, KEY_READ, &applicationsKey)
pluginAllUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE, &deprovisionedKey)
pluginAppxKey.OpenSubKey( s_StagedUserAcquired, KEY_READ, &this->pluginStagedUserAcquiredKey)
PluginExecutedInOfflineMode
PluginHasExecutedOffline
preferredMap->Insert(packageFamilyName->GetChars(), newBundleAndMainPackage.Value())
preferredMap->Insert(packageLineageName->GetChars(), currentPackage)
preferredMap->Remove(packageLineageName->GetChars())
PreferStub
PreRegisterAllInboxPackages failed 0x%x
PreRegisterAllInboxPackages()
PreRegistering Staged package %ws
PreRegisterPackagesInRegistryKey(&stagedKey, PreRegisterOptions::ReIndex)
PreRegisterPackagesInRegistryKey(&this->pluginStagedKey)
PreRegisterPackagesInRegistryKey(&this->pluginStagedUserAcquiredKey)
PreRegisterUplevelImagePackages()
PreserveMetadataForPackage(fullName)
ProcessAllBundleResourceAndOptionalPackagesUsingGatheredData()
ProcessAllMainAndFrameworkPackagesUsingGatheredData()
ProcessBundleForUserUsingGatheredData( packageKey, packageFamilyName, userSid, &bundleFullName)
processElementMethod(packageInfo.Get(), packageFullNameAsString.GetRawBuffer(nullptr))
ProcessFrameworkUsingGatheredData(packageFullName)
Processing %s
Processing all installed packages
Processing all Packages for user %ws
Processing all user store packages
Processing appx provision XML
Processing DevMode or Inbox Package %ws for user %ws
Processing downlevel all-user framework package %ws 
Processing downlevel all-user provisioned package %ws 
Processing Package %ws
Processing package %ws for ApplyTrustLabel
Processing Package %ws for user %ws
Processing Staged package %ws for preregister
Processing Staged package %ws to copy metadata
Processing sub-key %s
ProcessMainOrBundlePackageUsingGatheredData(packageFullName)
ProcessPackagesForUserUsingGatheredData(this->userSids.At(i)->GetChars())
ProcessPackagesToApplyUsingGatheredData
ProcessPackagesToApplyUsingGatheredData completed successfully
ProcessPackagesToApplyUsingGatheredData()
ProcessResourcePackageUsingGatheredData(packageFullName)
ProcessSingletonPackagesHelperFailed
ProductName
ProductVersion
Provisioned
provisionedAttemptedPackageFamilies->InsertIgnoreDuplicates(packageFamilyName.GetChars())
provisionedInstalledPackageFullNames->Insert(familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
provisionedPackages->GetCurrent(&package)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(bundleFullName)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(mainPackageFullName)
ProvisionSourceIsBundle
q)W\j
q*Z~:
q:_0#
q\Q17
q0R^G'
qB^Xh
QueryApplicationCapabilitiesEx
QueryPerformanceCounter
QueryServiceStatus
R!s4Z
r#fD9
RaiseException
RCV2D9
ReadAppXMigrationStoresUsingGatheredData()
reader->GetListEnumerator( ProvisionPackageList_EndOfLife, &eolPackages)
reader->GetListEnumerator( ProvisionPackageList_Provisioned, &provisionedPackages)
ReadFile
Reading Appx Migration Stores failed with 0x%x. Ignoring this error so we attempt to write migration XML.
Reading provisioning XML from location: %ws
realloc
RecursiveCopyDirectoryExceptAutogen(metadataFolderInSharedLimitedTime.GetChars(), metadataFolder.GetChars())
RecursiveCopyDirectoryExceptAutogen(srcPath.GetChars(), destPath.GetChars())
Redmond1
RegCloseKey
RegCopyTreeW
RegCreateKeyExW
RegDeleteKeyExW
RegDeleteTreeW
RegDeleteValueW
RegEnumKeyExW
RegEnumValueW
RegGetKeySecurity
RegGetValueW
Regions
Registry key value [%s] does not exist. The package may not be fully registered yet.
Registry Package entry has invalid Path
registry.GetStringValue(s_PackageRepositoryRoot, MAX_EXTENDED_PATH, &this->packageRepository)
registry.GetStringValue(s_PackageRoot, MAX_EXTENDED_PATH, &this->singleInstanceStore)
registry.Open(HKEY_LOCAL_MACHINE, Common::Deployment::AppXRegKeyPath.chars, KEY_READ)
registry.Open(HKEY_LOCAL_MACHINE, offlineAppxRegKeyPath.GetChars(), KEY_READ)
registryKey->CreateSubKey(packageSubKey.GetChars(), KEY_READ | KEY_WRITE, subKey)
registryKey->IsNull()
registryKey->Open(HKEY_USERS, effectiveUserPath, KEY_READ | KEY_WOW64_64KEY)
registryKey->OpenSubKey(fullName, KEY_READ, &packageFullNameKey)
registryKey->OpenSubKey(subKeyName, KEY_READ, &subKey)
registryPathBuilder.AppendString(hivePrefix)
registryPathBuilder.AppendString(onlineRegistryPath)
regkey.DeleteValueIfExists(L"MaintenanceLastPerformed")
regkey.Open(HKEY_LOCAL_MACHINE, stateRepositoryRegistryStatusSubkey, KEY_READ | KEY_WRITE)
regkey.SetUInt32Value(stateRepositoryRegistryNameAutoCheckIntegrity, autoCheckIntegrityOptions_FixIntegrity)
RegOpenKeyExW
RegQueryInfoKey
RegQueryInfoKeyW
RegQueryValueExW
RegSetKeySecurity
RegSetValueExW
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
Removed deprovisioned package %ws from uplevel key.
RemoveDirectoryW
Removing uplevel provisioned unneeded packages
RepairPathValueInUserRegistryKey(userSid, keyPath, bstrExpandedSisPath.Value(), offlineMode)
Replacing bad path in reg key value [%s] with: %s
repositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa->CheckIntegrity(Windows::Internal::StateRepository::Management::IntegrityOptions_Fix)
repositoryManager->CheckIntegrity(options, &integrityDisposition, &countOfErrorsCorrected)
repositoryManager->Repair(Windows::Internal::StringReference(userSid == nullptr ? L"" : userSid).Get(), ((userSid == nullptr) || (userSid[0] == L'\0')) ? Windows::Internal::StateRepository::Management::RepairOptions_NoUser : Windows::Internal::StateRepository::Management::RepairOptions_NoMachine, &found, &deleted)
ResetStateRepositoryMaintenance called
ResetStateRepositoryMaintenance done
ResetStateRepositoryMaintenance()
resource
Resource
resourcePackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
result == 0
RETURN_HR_IF(%S) failed with 0x%x
RETURN_HR_IF_FALSE(%S) failed with 0x%x
RETURN_HR_IF_MSG(%S) failed with 0x%x. Message is below:
RETURN_IF_FAILED(%S) failed with 0x%x
RETURN_IF_FAILED_MSG(%S) failed with 0x%x. Message is below:
RETURN_IF_WIN32_BOOL_FALSE(%S) failed with 0x%x
RETURN_LAST_ERROR_IF(%S) failed with 0x%x
RETURN_LAST_ERROR_IF_NULL(%S) failed with 0x%x
ReturnHr
ReturnNt
rJfD9?w
RoActivateInstance
RoGetActivationFactory
RoOriginateError
RoTransformError
RSDS2
RtlAcquireSRWLockExclusive
RtlAcquireSRWLockShared
RtlAllocateHeap
RtlCaptureContext
RtlCompareUnicodeString
RtlDeleteElementGenericTableAvl
RtlEnumerateGenericTableWithoutSplayingAvl
RtlFreeHeap
RtlGetDeviceFamilyInfoEnum
RtlGetVersion
RtlGetVersion failed with error code: 0x%x
RtlInitializeGenericTableAvl
RtlInitUnicodeString
RtlInsertElementGenericTableAvl
RtlIsGenericTableEmptyAvl
RtlIsStateSeparationEnabled
RtlLookupElementGenericTableAvl
RtlLookupFunctionEntry
RtlNotifyFeatureUsage
RtlNtStatusToDosErrorNoTeb
RtlReAllocateHeap
RtlRegisterFeatureConfigurationChangeNotification
RtlReleaseSRWLockExclusive
RtlReleaseSRWLockShared
RtlUnregisterFeatureConfigurationChangeNotification
RtlVirtualUnwind
S-1-0-0
S-1-1-0
S-1-15-3-1024-3635283841-2530182609-996808640-1887759898-3848208603-3313616867-983405619-2501854204
S-1-5-18
Same package was already found
SaveUpgradeDataToPluginKey()
searchPathBuilder.AppendString(L"\\*")
searchPathBuilder.AppendString(offlineSystemSisPath.GetChars())
searchPathBuilder.AppendString(this->singleInstanceStore.GetChars())
searchString.SetValueFromString(sourceDirectory)
searchStringBuilder.AppendString(L"\\*")
searchStringBuilder.AppendString(L"\\*.xml")
searchStringBuilder.AppendString(packagePath)
searchStringBuilder.AppendString(this->packageRepository.GetString())
SelectionNamespaces
SetCapacity %u
SetEntriesInAclW
SetEvent
SetFileAttributesW
SetFixStateRepositoryAlreadyExecuted()
SetLastError
SetNamedSecurityInfoW
SetPluginHasExecutedOffline succeeded for value-name: %ws.
SetPluginHasExecutedOffline()
SetPreferredBundleAndMainPackageFields(existingBundleAndMainPackage, packageFullName, isBundle, packageIsPaused, packageIsStub, true )
SetPreferredBundleAndMainPackageFields(newBundleAndMainPackage, packageFullName, isBundle, packageIsPaused, packageIsStub, false )
SetThreadpoolTimer
SetUnhandledExceptionFilter
SetupPhase
SharedLimitedTime metadata directory exists but metadata directory does not exist for %ws. Not copying files
SharedLimitedTime metadata directory exists: Preparing to copy metadata
SharedLimitedTime\
SisDirectory
sisDirectoryKey.CreateSubKey(subFolderName, KEY_READ | KEY_WRITE, &directoryKey)
sisDirectoryKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &subKey)
SisPath
Skipping AppxPreRegisterAllInboxPackages
Skipping package root folder path value not in single instance store (for example, system apps): %s. Value length: %u
Skipping ProcessPackagesToApplyUsingGatheredData since it has already executed.
Sleep
Software
Software\
Software\Classes\ActivatableClasses
Software\Classes\AppX$
Software\Classes\Extensions
Software\Classes\Folder
Software\Classes\FolderTypes
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Mappings
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\SystemAppData
Software\Classes\PackagedCom
SOFTWARE\Microsoft\Messaging
Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Microsoft\Windows\CurrentVersion\AppHost\IndexedDB
Software\Microsoft\Windows\CurrentVersion\AppModel
Software\Microsoft\Windows\CurrentVersion\AppModel\StateChange
SOFTWARE\Microsoft\Windows\CurrentVersion\AppModel\StateRepositoryStatus
Software\Microsoft\Windows\CurrentVersion\AppSync
Software\Microsoft\Windows\CurrentVersion\Appx
Software\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore
Software\Microsoft\Windows\CurrentVersion\AppX\ByteCodeQueue
Software\Microsoft\Windows\CurrentVersion\Appx\PackageVolumes
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Alarm
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\BackgroundCapability
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Badge
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Tile
Software\Microsoft\Windows\CurrentVersion\DeviceCapabilities
Software\Microsoft\Windows\CurrentVersion\Explorer\AutoplayHandlers\Handlers
Software\Microsoft\Windows\CurrentVersion\PushNotifications
Software\RegisteredApplications
source.OpenSubKey(subKeyName, KEY_READ, &sourceSubKey)
sourceBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
sourceBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
sourceBackupManifestFilePathBuilder.AppendString(manifestPathBuffer.GetChars())
sp^Z6
SRCheckIntegrity
srCheckIntegrity(options, &disposition)
SRImportPackageUserStatus
srImportPackageUserStatus(userSidString, userPath.GetChars(), &numImported, &numFailedToImport)
Staged
stagedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, stagedSD)
stagedKey.Open( HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ | KEY_WRITE | WRITE_DAC)
stagedKey.Open(HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ)
StagedUserAcquired
Starting AppxPreRegisterAllInboxPackages
Starting AppxUpgradeMigration Plugin during Apply Success
Starting AppxUpgradeMigration Plugin during Discover for %s
Starting AppxUpgradeMigration Plugin during Gather
Starting EnsureAppRootPermissions
Starting EnsureRegistryKeyPermissions
Starting EnumAndAddPackagesNotKnownToCapAuth
Starting FixStateRepositoryIntegrity.
Starting ImportPackageUserStatusToStateRepository
Starting ProcessPackagesToApplyUsingGatheredData
Starting RepairBadPathsInHKU
Starting RepairPackageRepositoryKeyInHKLM
Starting RepairPackageRootFolderPathInRepositoryRegistryKey
Starting RepairPathValueInUserRegistryKey. Inspect all immediate sub-keys under HKEY_USERS\%s%s and repair key values containing bad paths
Starting RepairStateRepository for %s.
StateChange
StateRepository
staterepository-machine.srd
stringArray->Add(packageSubKey)
StringCchCopy(packageFullNameChunk, packageFullNameChunkLength, trimmedChunk)
StringCchLengthW(expandedPath, Common::String::MaxLength, &expandedPathLength)
StringCchLengthW(expandedSisPath, Common::String::MaxLength, &sisPathLength)
StringCchPrintfW(pathname.get(), pathnameLength, L"%s\\%s%s", workingDir.get(), subdir, filename)
StringFileInfo
stringVector->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
StubPreference
subFolderActionFunction(findFileData.cFileName, fullFilePath.GetChars())
subKey->SetStringValue(AppxAllUserStore::regValuePath, *packagePath)
Successful delay-load of GetStagedPackagePathByFullName
Successfully finished processing all packages during AppxUpgradeMigration ApplySuccess
Successfully finished processing all packages during AppxUpgradeMigration Discover
Successfully finished processing all users and packages during AppxUpgradeMigration Gather
SVWAVH
system
SYSTEM\Setup\Upgrade\Appx
systemMetadataDirectoryForPackage.IsNull()
t"@8=
t$ E3
t$ UWATAVAWH
t$ UWAVH
t$ UWAWH
t$ WATAUAVAWH
t$ WAVAWH
t$ WH
t$`uFE3
t$1@8
T$8L+
T$dfD
t$hL9|$`u
T$PE3
t$PE3
T$PE3
t$pfD
T$PL;
t$XE3
t%H9x
t(D8%
t(D8%Hn
t(D8-5w
t,D8=
t?H9X
t[f9+tV
t_L9h
t`H!\$HH
t+H9^
t9L9h
tAfA9(t;H
targetBackupManifestFilePathBuilder.AppendChar('\\')
targetBackupManifestFilePathBuilder.AppendString(appRepositoryExpandedPath)
targetBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
targetBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
TerminateProcess
tgfD9e
Thales TSS ESN:4D2F-E3DD-BEEF1%0#
this->allUserFrameworkSet.InsertIgnoreDuplicates(subKey)
this->allUserPackages.InsertIgnoreDuplicates(subKey)
this->appModelRuntimeApisetHandle
this->AppxPreRegisterAllInboxPackages
this->AppxPreRegisterPackage
this->context->ExpandEnvironmentVariables(bstrPath, &bstrExpandedPath)
this->context->ExpandEnvironmentVariables(bstrSisPath, &bstrExpandedSisPath)
this->context->get_WorkingDir(&workingDir)
this->context->GetOfflineFileLocation( bstrOnlineFilePath.Value(), &bstrOfflineFilePath)
this->context->GetOfflineRegistryLocation( bstrOnlineRegistryPath.Value(), &bstrOfflineRegistryPath)
this->deploymentClientDllModule
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMessagingEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMobilePlansEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(familyName)
this->excludeFilesSet.InsertIgnoreDuplicates(filePath.GetChars())
this->excludeInfusedAppsFolderSet.InsertIgnoreDuplicates(packageFullPath.GetChars())
this->excludePackageFullNameSet.InsertIgnoreDuplicates(fullName)
this->excludePackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())
this->GetContext()->get_UserSidString(&userSid)
this->GetContext()->GetOfflineStatus(&offlineExecution)
this->GetStagedPackagePathByFullName
this->includeMetadataSet.InsertIgnoreDuplicates(metadataPath.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates( familyNameBuffer.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->noReRegisterOnUpgrade
this->oemProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->pluginAllUserStoreKey.CopyTree(nullptr, allUserStoreKey)
this->pluginAllUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &this->pluginDeprovisionedKey)
this->pluginAllUserStoreKey.CreateSubKey( s_DownlevelInstalled, KEY_READ | KEY_WRITE, &this->pluginDownlevelInstalledKey)
this->pluginAllUserStoreKey.CreateSubKey( s_EndOfLife, KEY_READ | KEY_WRITE, &this->pluginEndOfLifeKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Staged, KEY_READ | KEY_WRITE, &this->pluginStagedKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Upgrade, KEY_READ | KEY_WRITE, &this->pluginUpgradeKey)
this->pluginAllUserStoreKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserInstalledKey)
this->pluginAllUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &this->pluginStagedKey)
this->pluginApplicationsKey.CreateSubKey( packageSubKey.GetChars(), KEY_ALL_ACCESS, &mainPackageKey)
this->pluginApplicationsKey.OpenSubKey(subKey, KEY_READ, &packageFamilyKey)
this->pluginAppxKey.Create(HKEY_LOCAL_MACHINE, pluginRegistryKeyPath, KEY_ALL_ACCESS)
this->pluginAppxKey.CreateSubKey( allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &this->pluginAllUserStoreKey)
this->pluginAppxKey.CreateSubKey( s_Applications, KEY_READ | KEY_WRITE, &this->pluginApplicationsKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToCheckForStagingCompletion, KEY_READ | KEY_WRITE, &this->pluginPackagesToCheckForStagingCompletionKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToRemove, KEY_READ | KEY_WRITE, &this->pluginPackagesToRemoveKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToReRegister, KEY_READ | KEY_WRITE, &this->pluginPackagesToReRegisterKey)
this->pluginAppxKey.CreateSubKey( s_StagedUserAcquired, KEY_READ | KEY_WRITE, &this->pluginStagedUserAcquiredKey)
this->pluginAppxKey.CreateSubKey(s_Applications, KEY_READ | KEY_WRITE, &applicationsKey)
this->pluginAppxKey.CreateSubKey(s_DownlevelGather, KEY_ALL_ACCESS, &this->pluginDownlevelGatherKey)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, &this->packageRepository)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, backupManifestDir)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, &this->singleInstanceStore)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, packageRoot)
this->pluginAppxKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
this->pluginAppxKey.Open(HKEY_LOCAL_MACHINE, effectivePluginPath, KEY_ALL_ACCESS)
this->pluginAppxKey.OpenSubKey(s_Applications, KEY_READ, &applicationsKey)
this->pluginAppxKey.OpenSubKey(s_DownlevelGather, KEY_READ, &this->pluginDownlevelGatherKey)
this->pluginAppxKey.SetBinaryValue(migXmlRegValueName, migXml, (SysStringLen(migXml) + 1) * sizeof(OLECHAR))
this->pluginAppxKey.SetStringValue(s_DownlevelPackageRepositoryRoot, this->packageRepository.GetChars())
this->pluginAppxKey.SetStringValue(s_DownlevelPackageSisRoot, this->singleInstanceStore.GetChars())
this->pluginAppxKey.SetUInt32Value(s_ProcessPackagesToApplyUsingGatheredData, 1)
this->pluginAppxKey.ValueExists(s_ProcessPackagesToApplyUsingGatheredData, &valueExists)
this->pluginDownlevelGatherKey.CreateSubKey(allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &pluginAllUserStoreKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_BundleManifestInfo, KEY_READ | KEY_WRITE, &bundleInfoRootKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeFiles, KEY_READ | KEY_WRITE, &excludeFilesKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeInfusedApps, KEY_READ | KEY_WRITE, &excludeInfusedAppsKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_InstalledPackages, KEY_READ | KEY_WRITE, &installedPackagesKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_PackageInstallState, KEY_READ | KEY_WRITE, &installStateRootKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_SisDirectory, KEY_READ | KEY_WRITE, &sisDirectoryKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_StateChange, KEY_READ | KEY_WRITE, &stateChangeKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_StubPreference, KEY_READ | KEY_WRITE, &stubPreferenceKeyCopy)
this->pluginDownlevelGatherKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &userKey)
this->pluginDownlevelGatherKey.OpenSubKey(allUserStoreRegistryKeyName, KEY_READ, &allUserStoreKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_BundleManifestInfo, KEY_READ, &bundleInfoRootKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_InstalledPackages, KEY_READ, &installedPackagesKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateRootKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_SisDirectory, KEY_READ, &sisDirectoryKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_StateChange, KEY_READ, &stateChangeKey)
this->pluginDownlevelGatherKey.OpenSubKey(userSid, KEY_READ, &userKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeFiles, KEY_READ, &excludeFilesKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeInfusedApps, KEY_READ, &excludeInfusedAppsKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_PackageInstallState, KEY_READ, &installStateRootKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_StubPreference, KEY_READ, &stubPreferenceRootKey)
this->pluginPackagesToCheckForStagingCompletionKey.CreateSubKey( packageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( provisionedPackageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( uplevelProvisionedPackage, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToReRegisterKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserReRegistrationKey)
this->stagedOnlyManifestPackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->uplevelProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(familyName.GetChars())
this->uplevelProvisionedPackageMap.Insert( familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
this->userSids.Add(userSid)
threadId
tjD9|$Xvc
TlP0X
TOC8uOA
tOD8}gtBH
TotalTimeTaken
Translation
tx@8=
tyfD9"tsH
u HcA<H
u%I!C
u@fD9u0A
u{H9A
U0S0Q
UATAUAVAWH
UAUAVH
UAVAWH
UAVAWI
Unable to clean-up orphan packages: 0x%x
Unable to clean-up SystemApps migrated to FOD: 0x%x
Unable to clear IsSingletonRegisteredFlags: 0x%x
Unable to copy backup manifest for end of life packages if necessary: 0x%x
Unable to copy metadata: 0x%x
Unable to DeleteOSRollbackPackagesRegistry: 0x%x
Unable to Mark up-level provisioned paused packages as staged: 0x%x
Unable to pre register packages: 0x%x
Unable to re index packages for feature light up: 0x%x
Unable to Remove up-level provisioned unneeded packages: 0x%x
Unable to repair bad path values in HKEY_USERS: 0x%x
Unable to repair Package Repository registry key values for packages: 0x%x
Unable to repair PackageRootFolder values for packages: 0x%x
Unable to repair StateRepository for %s: 0x%x
Unable to SavePackageListFromFileToRegistry: 0x%x
Unable to set security descriptor for all user store key with 0x%x
Unable to set security descriptor for deprovisioed key with 0x%x
Unable to set security descriptor for end of life key with 0x%x
Unable to set security descriptor for staged key with 0x%x
Unable to set up packages for re-registration: 0x%x
Unable to write all user store keys 0x%x
Unexpected failure from ExpandEnvironmentStrings on string %s. Buffer size %u characters. Required size %u characters
Unexpected failure from ExpandEnvironmentVariables on string %s
UnhandledExceptionFilter
unknown
Unnecessary. Skipping EnumAndAddPackagesNotKnownToCapAuth
UpdateProcThreadAttribute
Upgrade
upgradeKey.Open(HKEY_LOCAL_MACHINE, upgradePath.GetChars(), KEY_READ | KEY_WRITE)
upgradeKey.OpenSubKey(userSid, KEY_READ, &userSidKey)
upgradeKey.SetUInt64Value(timeElapsedValueName, timeElapsed)
upgradeKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
Uplevel Provisioned package: %ws found in appxprovisioning.xml
uplevelPackageToDelete->SetValueFromString(fullNameKey)
uplevelStubPreferenceKey.CreateSubKey(packageFamilyName.GetChars(), KEY_READ | KEY_WRITE, &packageFamilyKey)
Use get_InstalledLocation to get package root
userClassesKeyNameBuilder.AppendString(registryClassesPrefix)
userClassesKeyNameBuilder.AppendString(userSid)
userInfo.Get()->get_InstallState(&installStateValue)
userInfo->get_UserSecurityId(userInfoSid.Address())
userInfoCollection->First(userInfoIterator.GetAddressOf())
userInfoIterator->get_Current(userInfo.GetAddressOf())
userInfoIterator->get_HasCurrent(&hasCurrent)
userInfoIterator->MoveNext(&hasCurrent)
userInfoSid.GetLpcwstr(&userAsLpcwstr)
userKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
userKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
userPathBuilder.AppendString(appxMiniRepositoryPackagesSubkey)
userPathBuilder.AppendString(registryClassesPrefix)
userPathBuilder.AppendString(subKey)
userPathBuilder.AppendString(userSidKeyName)
userPathBuilder.AppendString(userSidString)
USERS\
userSid->SetValueFromString(subKey)
userSidAsInternalString.Initialize(userSid, static_cast<ULONG>(wcslen(userSid)))
userSidKey.KeyExists(packageFullName, isPackageEndOfLife)
USVWATAUAVAWH
USVWAVH
USWATAUAVAWH
UVATAVAWH
UVWATAUAVAWH
UVWATAVH
UVWAVAWH
UWATAUAWH
UWATAVAWH
UWATH
UWAUAVAWH
UWAVH
UWAWH
v$A+H
valueBuffer.SetCapacity(valueBufferLength)
valueNameBuilder.AppendString(pluginHasExecutedOfflineValueName)
valueNameBuilder.AppendString(userSid ? userSid.get() : L"")
VarFileInfo
VerQueryValueW
version="1.0" encoding="utf-8"
versionData.IsNull()
VS_VERSION_INFO
VWATAVAWH
VWAVH
WaitForSingleObject
WaitForSingleObjectEx
WaitForThreadpoolTimerCallbacks
Washington1
WATAUAVAWH
WATAVH
WAVAWH
wcscmp
wcsrchr
wcsstr
wilResult
WilStaging_02
Windows.Foundation.Collections.IIterator`1<String>
Windows.Foundation.Collections.IVector`1<String>
Windows.Foundation.Collections.IVectorView`1<String>
Windows.Internal.StateRepository.Management.RepositoryManager
Windows.Internal.StateRepository.Package
Windows.Management.Deployment.Internal.PackageManagerInternal
Windows.Management.Deployment.PackageManager
Windows.MiracastView_6.3.0.0_neutral_neutral_cw5n1h2txyewy
Windows::Foundation::ActivateInstance( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Management_Deployment_Internal_PackageManagerInternal).Get(), &packageManager)
Windows::Foundation::ActivateInstance( Windows::Internal::StringReference(RuntimeClass_Windows_Internal_StateRepository_Management_RepositoryManager).Get(), &repositoryManager)
Windows::Foundation::ActivateInstance(acid.Get(), &inspectable)
Windows::Foundation::ActivateInstance(strActivatableClassId.Get(), &packageManager)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToCheckForStagingCompletion)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToReRegister)
Windows::Foundation::GetActivationFactory( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Internal_StateRepository_Package).Get(), &packageStatics)
Windows::Foundation::GetActivationFactory(acid.Get(), &packageStatics)
WindowsCreateString
WindowsCreateStringReference
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
WindowsStringHasEmbeddedNull
WriteAllProvisionedUninstalledPackageKeysToListUsingGatheredData( userSid, provisionedInstalledPackageFullNames, &provisionedUninstalledPackageFullNames)
WriteDeprovisionListToPluginAllUserStoreUsingGatheredData()
WriteFile
WriteOutRegistryIncludeRules( MigXmlRules::perMachineRegistryRules, ARRAYSIZE(MigXmlRules::perMachineRegistryRules), true, xmlWriter)
WriteOutRegistryIncludeRules( MigXmlRules::perUserRegistryRules, ARRAYSIZE(MigXmlRules::perUserRegistryRules), false, xmlWriter)
WritePackageAlreadyInstalledForUserKey(userSid, fullNameToWrite)
WritePackageAlreadyInstalledForUserKey(userSid, package)
WritePackageRegistryKey( packageElement->GetKey(), bundleFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageElement->GetKey(), mainPackageFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageFamilyName, bundleFullName->GetChars(), userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
WritePackageRegistryKey( packageFamilyName, fullNameToWrite, userSid, &this->pluginUpgradeKey, s_Upgrade, &createdKey)
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageFamilyName.GetChars(), packageFullName, userSid, &this->pluginStagedUserAcquiredKey, s_Staged)
WritePackageRegistryKey( packageFullName, userSid, &this->pluginEndOfLifeKey, s_EndOfLife)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled, packageRoot.GetString(), &downlevelInstalledKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginUpgradeKey, s_Upgrade, packageRoot.GetString(), &upgradeKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, registryKey, keyName, manifestPath.GetString(), createdKey)
WritePackagesToCheckPostUpgradeToSetupKeyUsingGatheredData()
Writing %ws Key %ws
Writing %ws Key %ws\%ws
Writing Applications Key %ws
Writing Downlevel all-user key %ws to uplevel key
Writing out to exclude file %ws in XML Writer.
Writing out to include directory %ws in XML Writer.
Writing out to include directory %ws, file %ws in XML Writer.
Writing out to include registry key %ws in XML Writer.
Writing out to include registry key %ws, value %ws in XML Writer.
Writing out to merge registry key %ws in XML Writer.
Writing out to merge registry key %ws, value %ws in XML Writer.
Writing out to move directory %ws to backup folder in XML Writer for OS downgrade.
Writing out to registry %ws in XML Writer.
Writing Package to PackagesToCheckForStagingCompletion Key: %ws
Writing up-level provisioned deprovisioned Package to PackagesToRemove Key: %ws
Writing up-level provisioned package to PackagesToRemove Key: %ws
x AVH
x UATAUAVAWH
X0V0T
x86a64
XA_A^_^][
xmD8|$@ufD
xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage"
xSu$W
Xz6Rh
z>{'X
